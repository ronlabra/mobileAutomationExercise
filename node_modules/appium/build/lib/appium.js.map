{"version":3,"file":"appium.js","names":["desiredCapabilityConstraints","automationName","presence","isString","platformName","sessionsListGuard","AsyncLock","pendingDriversGuard","AppiumDriver","DriverCore","sessions","pendingDrivers","newCommandTimeoutMs","pluginClasses","sessionPlugins","sessionlessPlugins","driverConfig","server","desiredCapConstraints","args","constructor","opts","tmpDir","process","env","APPIUM_TMP_DIR","updateBuildInfo","e","log","debug","message","_log","instanceName","name","node","getObjectId","substring","logger","getLogger","isCommandsQueueEnabled","sessionExists","sessionId","dstSession","driverForSession","getStatus","build","_","clone","getBuildInfo","getSessions","toPairs","map","id","driver","capabilities","caps","printNewSessionAnnouncement","driverName","driverVersion","driverBaseVersion","info","APPIUM_VER","baseVersion","getCliArgsForPlugin","extName","plugin","getCliArgsForDriver","allCliArgsForExt","isEmpty","defaults","getDefaultsForExtension","DRIVER_TYPE","cliArgs","omitBy","value","key","isEqual","createSession","jsonwpCaps","reqCaps","w3cCapabilities","driverData","defaultCapabilities","cloneDeep","defaultSettings","pullSettings","jwpSettings","w3cSettings","alwaysMatch","firstMatchEntry","firstMatch","Object","assign","protocol","innerSessionId","dCaps","parsedCaps","parseCapsForInnerDriver","desiredCaps","processedJsonwpCapabilities","processedW3CCapabilities","error","InnerDriver","version","findMatchingDriver","sessionOverride","deleteAllSessions","runningDriversData","otherPendingDriversData","driverInstance","relaxedSecurityEnabled","denyInsecure","a","allowInsecure","serverHost","address","serverPort","port","serverPath","basePath","curSessionDataForDriver","errors","SessionNotCreatedError","acquire","compact","drv","push","pull","attachUnexpectedShutdownHandler","startNewCommandTimeout","isW3CProtocol","JSON","stringify","updateSettings","isMjsonwpProtocol","onShutdown","cause","Error","warn","isFunction","onUnexpectedShutdown","data","values","filter","s","datum","deleteSession","otherSessionsData","curConstructorName","sessionsCount","size","force","reason","util","pluralize","cleanupPromises","startUnexpectedShutdown","keys","cleanupPromise","pluginsForSession","createPluginInstances","pluginsToHandleCmd","cmd","p","handle","pluginInstances","PluginClass","entries","executeCommand","isGetStatus","GET_STATUS_COMMAND","isUmbrellaCmd","isAppiumDriverCommand","isSessionCmd","isSessionCommand","reqForProxy","last","pop","plugins","cmdHandledBy","default","defaultBehavior","length","proxyCommand","NoDriverProxyCommandError","originalUrl","method","body","BaseDriver","prototype","call","wrappedCmd","wrapCommandWithPlugins","next","res","executeWrappedCommand","logPluginHandlerReport","CREATE_SESSION_COMMAND","first","_next","didHandle","k","didntHandle","cmdRes","cmdErr","isPlainObject","has","proxyActive","getProxyAvoidList","canProxy","DELETE_SESSION_COMMAND","code"],"sources":["../../lib/appium.js"],"sourcesContent":["/* eslint-disable no-unused-vars */\nimport _ from 'lodash';\nimport {getBuildInfo, updateBuildInfo, APPIUM_VER} from './config';\nimport {\n  BaseDriver,\n  DriverCore,\n  errors,\n  isSessionCommand,\n  CREATE_SESSION_COMMAND,\n  DELETE_SESSION_COMMAND,\n  GET_STATUS_COMMAND,\n} from '@appium/base-driver';\nimport AsyncLock from 'async-lock';\nimport {parseCapsForInnerDriver, pullSettings} from './utils';\nimport {util, node, logger} from '@appium/support';\nimport {getDefaultsForExtension} from './schema';\nimport {DRIVER_TYPE} from './constants';\n\nconst desiredCapabilityConstraints = /** @type {const} */ ({\n  automationName: {\n    presence: true,\n    isString: true,\n  },\n  platformName: {\n    presence: true,\n    isString: true,\n  },\n});\n/**\n * @typedef {typeof desiredCapabilityConstraints} AppiumDriverConstraints\n */\n\nconst sessionsListGuard = new AsyncLock();\nconst pendingDriversGuard = new AsyncLock();\n\n/**\n * @implements {SessionHandler}\n */\nclass AppiumDriver extends DriverCore {\n  /**\n   * Access to sessions list must be guarded with a Semaphore, because\n   * it might be changed by other async calls at any time\n   * It is not recommended to access this property directly from the outside\n   * @type {Record<string,ExternalDriver>}\n   */\n  sessions = {};\n\n  /**\n   * Access to pending drivers list must be guarded with a Semaphore, because\n   * it might be changed by other async calls at any time\n   * It is not recommended to access this property directly from the outside\n   * @type {Record<string,ExternalDriver[]>}\n   */\n  pendingDrivers = {};\n\n  /**\n   * Note that {@linkcode AppiumDriver} has no `newCommandTimeout` method.\n   * `AppiumDriver` does not set and observe its own timeouts; individual\n   * sessions (managed drivers) do instead.\n   */\n  newCommandTimeoutMs = 0;\n\n  /**\n   * List of active plugins\n   * @type {Map<PluginClass,string>}\n   */\n  pluginClasses;\n\n  /**\n   * map of sessions to actual plugin instances per session\n   * @type {Record<string,InstanceType<PluginClass>[]>}\n   */\n  sessionPlugins = {};\n\n  /**\n   * some commands are sessionless, so we need a set of plugins for them\n   * @type {InstanceType<PluginClass>[]}\n   */\n  sessionlessPlugins = [];\n\n  /** @type {DriverConfig} */\n  driverConfig;\n\n  /** @type {AppiumServer} */\n  server;\n\n  desiredCapConstraints = desiredCapabilityConstraints;\n\n  /** @type {DriverOpts} */\n  args;\n\n  /**\n   * @param {DriverOpts} opts\n   */\n  constructor(opts) {\n    // It is necessary to set `--tmp` here since it should be set to\n    // process.env.APPIUM_TMP_DIR once at an initial point in the Appium lifecycle.\n    // The process argument will be referenced by BaseDriver.\n    // Please call @appium/support.tempDir module to apply this benefit.\n    if (opts.tmpDir) {\n      process.env.APPIUM_TMP_DIR = opts.tmpDir;\n    }\n\n    super(opts);\n\n    this.args = {...opts};\n\n    // allow this to happen in the background, so no `await`\n    (async () => {\n      try {\n        await updateBuildInfo();\n      } catch (e) {\n        // make sure we catch any possible errors to avoid unhandled rejections\n        this.log.debug(`Cannot fetch Appium build info: ${e.message}`);\n      }\n    })();\n  }\n\n  /**\n   * Retrieves logger instance for the current umbrella driver instance\n   */\n  get log() {\n    if (!this._log) {\n      const instanceName = `${this.constructor.name}@${node.getObjectId(this).substring(0, 4)}`;\n      this._log = logger.getLogger(instanceName);\n    }\n    return this._log;\n  }\n\n  /**\n   * Cancel commands queueing for the umbrella Appium driver\n   */\n  get isCommandsQueueEnabled() {\n    return false;\n  }\n\n  sessionExists(sessionId) {\n    const dstSession = this.sessions[sessionId];\n    return dstSession && dstSession.sessionId !== null;\n  }\n\n  driverForSession(sessionId) {\n    return this.sessions[sessionId];\n  }\n\n  // eslint-disable-next-line require-await\n  async getStatus() {\n    return {\n      build: _.clone(getBuildInfo()),\n    };\n  }\n\n  // eslint-disable-next-line require-await\n  async getSessions() {\n    return _.toPairs(this.sessions).map(([id, driver]) => ({\n      id,\n      capabilities: driver.caps,\n    }));\n  }\n\n  printNewSessionAnnouncement(driverName, driverVersion, driverBaseVersion) {\n    this.log.info(\n      driverVersion\n        ? `Appium v${APPIUM_VER} creating new ${driverName} (v${driverVersion}) session`\n        : `Appium v${APPIUM_VER} creating new ${driverName} session`\n    );\n    this.log.info(`Checking BaseDriver versions for Appium and ${driverName}`);\n    this.log.info(\n      AppiumDriver.baseVersion\n        ? `Appium's BaseDriver version is ${AppiumDriver.baseVersion}`\n        : `Could not determine Appium's BaseDriver version`\n    );\n    this.log.info(\n      driverBaseVersion\n        ? `${driverName}'s BaseDriver version is ${driverBaseVersion}`\n        : `Could not determine ${driverName}'s BaseDriver version`\n    );\n  }\n\n  /**\n   * Retrieves all CLI arguments for a specific plugin.\n   * @param {string} extName - Plugin name\n   * @returns {StringRecord} Arguments object. If none, an empty object.\n   */\n  getCliArgsForPlugin(extName) {\n    return /** @type {StringRecord} */ (this.args.plugin?.[extName] ?? {});\n  }\n\n  /**\n   * Retrieves CLI args for a specific driver.\n   *\n   * _Any arg which is equal to its default value will not be present in the returned object._\n   *\n   * _Note that this behavior currently (May 18 2022) differs from how plugins are handled_ (see {@linkcode AppiumDriver.getCliArgsForPlugin}).\n   * @param {string} extName - Driver name\n   * @returns {StringRecord|undefined} Arguments object. If none, `undefined`\n   */\n  getCliArgsForDriver(extName) {\n    const allCliArgsForExt = /** @type {StringRecord|undefined} */ (this.args.driver?.[extName]);\n\n    if (!_.isEmpty(allCliArgsForExt)) {\n      const defaults = getDefaultsForExtension(DRIVER_TYPE, extName);\n      const cliArgs = _.isEmpty(defaults)\n        ? allCliArgsForExt\n        : _.omitBy(allCliArgsForExt, (value, key) => _.isEqual(defaults[key], value));\n      if (!_.isEmpty(cliArgs)) {\n        return cliArgs;\n      }\n    }\n  }\n\n  /**\n   * Create a new session\n   * @param {W3CCapabilities<AppiumDriverConstraints>} jsonwpCaps JSONWP formatted desired capabilities\n   * @param {W3CCapabilities<AppiumDriverConstraints>} reqCaps Required capabilities (JSONWP standard)\n   * @param {W3CCapabilities<AppiumDriverConstraints>} w3cCapabilities W3C capabilities\n   * @param {DriverData[]} [driverData]\n   */\n  async createSession(jsonwpCaps, reqCaps, w3cCapabilities, driverData) {\n    const defaultCapabilities = _.cloneDeep(this.args.defaultCapabilities);\n    const defaultSettings = pullSettings(defaultCapabilities);\n    jsonwpCaps = _.cloneDeep(jsonwpCaps);\n    const jwpSettings = {...defaultSettings, ...pullSettings(jsonwpCaps)};\n    w3cCapabilities = _.cloneDeep(w3cCapabilities);\n    // It is possible that the client only provides caps using JSONWP standard,\n    // although firstMatch/alwaysMatch properties are still present.\n    // In such case we assume the client understands W3C protocol and merge the given\n    // JSONWP caps to W3C caps\n    const w3cSettings = {\n      ...jwpSettings,\n      ...pullSettings((w3cCapabilities ?? {}).alwaysMatch ?? {}),\n    };\n    for (const firstMatchEntry of (w3cCapabilities ?? {}).firstMatch ?? []) {\n      Object.assign(w3cSettings, pullSettings(firstMatchEntry));\n    }\n\n    let protocol;\n    let innerSessionId, dCaps;\n    try {\n      // Parse the caps into a format that the InnerDriver will accept\n      const parsedCaps = parseCapsForInnerDriver(\n        jsonwpCaps,\n        w3cCapabilities,\n        this.desiredCapConstraints,\n        defaultCapabilities\n      );\n\n      const {desiredCaps, processedJsonwpCapabilities, processedW3CCapabilities} =\n        /** @type {import('./utils').ParsedDriverCaps<AppiumDriverConstraints>} */ (parsedCaps);\n      protocol = parsedCaps.protocol;\n      const error = /** @type {import('./utils').InvalidCaps<AppiumDriverConstraints>} */ (\n        parsedCaps\n      ).error;\n      // If the parsing of the caps produced an error, throw it in here\n      if (error) {\n        throw error;\n      }\n\n      const {\n        driver: InnerDriver,\n        version: driverVersion,\n        driverName,\n      } = this.driverConfig.findMatchingDriver(desiredCaps);\n      this.printNewSessionAnnouncement(InnerDriver.name, driverVersion, InnerDriver.baseVersion);\n\n      if (this.args.sessionOverride) {\n        await this.deleteAllSessions();\n      }\n\n      /**\n       * @type {DriverData[]}\n       */\n      let runningDriversData = [];\n      /**\n       * @type {DriverData[]}\n       */\n      let otherPendingDriversData = [];\n\n      const driverInstance = new InnerDriver(this.args, true);\n\n      // We want to assign security values directly on the driver. The driver\n      // should not read security values from `this.opts` because those values\n      // could have been set by a malicious user via capabilities, whereas we\n      // want a guarantee the values were set by the appium server admin\n      if (this.args.relaxedSecurityEnabled) {\n        this.log.info(\n          `Applying relaxed security to '${InnerDriver.name}' as per ` +\n            `server command line argument. All insecure features will be ` +\n            `enabled unless explicitly disabled by --deny-insecure`\n        );\n        driverInstance.relaxedSecurityEnabled = true;\n      }\n\n      if (!_.isEmpty(this.args.denyInsecure)) {\n        this.log.info('Explicitly preventing use of insecure features:');\n        this.args.denyInsecure.map((a) => this.log.info(`    ${a}`));\n        driverInstance.denyInsecure = this.args.denyInsecure;\n      }\n\n      if (!_.isEmpty(this.args.allowInsecure)) {\n        this.log.info('Explicitly enabling use of insecure features:');\n        this.args.allowInsecure.map((a) => this.log.info(`    ${a}`));\n        driverInstance.allowInsecure = this.args.allowInsecure;\n      }\n\n      // Likewise, any driver-specific CLI args that were passed in should be assigned directly to\n      // the driver so that they cannot be mimicked by a malicious user sending in capabilities\n      const cliArgs = this.getCliArgsForDriver(driverName);\n      if (!_.isEmpty(cliArgs)) {\n        driverInstance.cliArgs = cliArgs;\n      }\n\n      // This assignment is required for correct web sockets functionality inside the driver\n      // Drivers/plugins might also want to know where they are hosted\n\n      // XXX: temporary hack to work around #16747\n      driverInstance.server = this.server;\n      driverInstance.serverHost = this.args.address;\n      driverInstance.serverPort = this.args.port;\n      driverInstance.serverPath = this.args.basePath;\n\n      try {\n        runningDriversData = (await this.curSessionDataForDriver(InnerDriver)) ?? [];\n      } catch (e) {\n        throw new errors.SessionNotCreatedError(e.message);\n      }\n      await pendingDriversGuard.acquire(AppiumDriver.name, () => {\n        this.pendingDrivers[InnerDriver.name] = this.pendingDrivers[InnerDriver.name] || [];\n        otherPendingDriversData = _.compact(\n          this.pendingDrivers[InnerDriver.name].map((drv) => drv.driverData)\n        );\n        this.pendingDrivers[InnerDriver.name].push(driverInstance);\n      });\n\n      try {\n        [innerSessionId, dCaps] = await driverInstance.createSession(\n          processedJsonwpCapabilities,\n          reqCaps,\n          processedW3CCapabilities,\n          [...runningDriversData, ...otherPendingDriversData]\n        );\n        protocol = driverInstance.protocol;\n        this.sessions[innerSessionId] = driverInstance;\n      } finally {\n        await pendingDriversGuard.acquire(AppiumDriver.name, () => {\n          _.pull(this.pendingDrivers[InnerDriver.name], driverInstance);\n        });\n      }\n\n      this.attachUnexpectedShutdownHandler(driverInstance, innerSessionId);\n\n      this.log.info(\n        `New ${InnerDriver.name} session created successfully, session ` +\n          `${innerSessionId} added to master session list`\n      );\n\n      // set the New Command Timeout for the inner driver\n      driverInstance.startNewCommandTimeout();\n\n      // apply initial values to Appium settings (if provided)\n      if (driverInstance.isW3CProtocol() && !_.isEmpty(w3cSettings)) {\n        this.log.info(\n          `Applying the initial values to Appium settings parsed from W3C caps: ` +\n            JSON.stringify(w3cSettings)\n        );\n        await driverInstance.updateSettings(w3cSettings);\n      } else if (driverInstance.isMjsonwpProtocol() && !_.isEmpty(jwpSettings)) {\n        this.log.info(\n          `Applying the initial values to Appium settings parsed from MJSONWP caps: ` +\n            JSON.stringify(jwpSettings)\n        );\n        await driverInstance.updateSettings(jwpSettings);\n      }\n    } catch (error) {\n      return {\n        protocol,\n        error,\n      };\n    }\n\n    return {\n      protocol,\n      value: [innerSessionId, dCaps, protocol],\n    };\n  }\n\n  /**\n   *\n   * @param {Driver} driver\n   * @param {string} innerSessionId\n   */\n  attachUnexpectedShutdownHandler(driver, innerSessionId) {\n    const onShutdown = (cause = new Error('Unknown error')) => {\n      this.log.warn(`Ending session, cause was '${cause.message}'`);\n\n      if (this.sessionPlugins[innerSessionId]) {\n        for (const plugin of this.sessionPlugins[innerSessionId]) {\n          if (_.isFunction(plugin.onUnexpectedShutdown)) {\n            this.log.debug(\n              `Plugin ${plugin.name} defines an unexpected shutdown handler; calling it now`\n            );\n            try {\n              plugin.onUnexpectedShutdown(driver, cause);\n            } catch (e) {\n              this.log.warn(\n                `Got an error when running plugin ${plugin.name} shutdown handler: ${e}`\n              );\n            }\n          } else {\n            this.log.debug(`Plugin ${plugin.name} does not define an unexpected shutdown handler`);\n          }\n        }\n      }\n\n      this.log.info(`Removing session '${innerSessionId}' from our master session list`);\n      delete this.sessions[innerSessionId];\n      delete this.sessionPlugins[innerSessionId];\n    };\n\n    if (_.isFunction(driver.onUnexpectedShutdown)) {\n      driver.onUnexpectedShutdown(onShutdown);\n    } else {\n      this.log.warn(\n        `Failed to attach the unexpected shutdown listener. ` +\n          `Is 'onUnexpectedShutdown' method available for '${driver.constructor.name}'?`\n      );\n    }\n  }\n\n  /**\n   *\n   * @param {DriverClass} InnerDriver\n   * @returns {Promise<DriverData[]>}}\n   */\n  // eslint-disable-next-line require-await\n  async curSessionDataForDriver(InnerDriver) {\n    const data = _.compact(\n      _.values(this.sessions)\n        .filter((s) => s.constructor.name === InnerDriver.name)\n        .map((s) => s.driverData)\n    );\n    for (const datum of data) {\n      if (!datum) {\n        throw new Error(\n          `Problem getting session data for driver type ` +\n            `${InnerDriver.name}; does it implement 'get driverData'?`\n        );\n      }\n    }\n    return data;\n  }\n\n  /**\n   * @param {string} sessionId\n   */\n  async deleteSession(sessionId) {\n    let protocol;\n    try {\n      let otherSessionsData;\n      const dstSession = await sessionsListGuard.acquire(AppiumDriver.name, () => {\n        if (!this.sessions[sessionId]) {\n          return;\n        }\n        const curConstructorName = this.sessions[sessionId].constructor.name;\n        otherSessionsData = _.toPairs(this.sessions)\n          .filter(\n            ([key, value]) => value.constructor.name === curConstructorName && key !== sessionId\n          )\n          .map(([, value]) => value.driverData);\n        const dstSession = this.sessions[sessionId];\n        protocol = dstSession.protocol;\n        this.log.info(`Removing session ${sessionId} from our master session list`);\n        // regardless of whether the deleteSession completes successfully or not\n        // make the session unavailable, because who knows what state it might\n        // be in otherwise\n        delete this.sessions[sessionId];\n        delete this.sessionPlugins[sessionId];\n        return dstSession;\n      });\n      // this may not be correct, but if `dstSession` was falsy, the call to `deleteSession()` would\n      // throw anyway.\n      if (!dstSession) {\n        throw new Error('Session not found');\n      }\n      return {\n        protocol,\n        value: await dstSession.deleteSession(sessionId, otherSessionsData),\n      };\n    } catch (e) {\n      this.log.error(`Had trouble ending session ${sessionId}: ${e.message}`);\n      return {\n        protocol,\n        error: e,\n      };\n    }\n  }\n\n  async deleteAllSessions(opts = {}) {\n    const sessionsCount = _.size(this.sessions);\n    if (0 === sessionsCount) {\n      this.log.debug('There are no active sessions for cleanup');\n      return;\n    }\n\n    const {force = false, reason} = opts;\n    this.log.debug(`Cleaning up ${util.pluralize('active session', sessionsCount, true)}`);\n    const cleanupPromises = force\n      ? _.values(this.sessions).map((drv) =>\n          drv.startUnexpectedShutdown(reason && new Error(reason))\n        )\n      : _.keys(this.sessions).map((id) => this.deleteSession(id));\n    for (const cleanupPromise of cleanupPromises) {\n      try {\n        await cleanupPromise;\n      } catch (e) {\n        this.log.debug(e);\n      }\n    }\n  }\n\n  /**\n   * Get the appropriate plugins for a session (or sessionless plugins)\n   *\n   * @param {?string} sessionId - the sessionId (or null) to use to find plugins\n   * @returns {Array} - array of plugin instances\n   */\n  pluginsForSession(sessionId = null) {\n    if (sessionId) {\n      if (!this.sessionPlugins[sessionId]) {\n        this.sessionPlugins[sessionId] = this.createPluginInstances();\n      }\n      return this.sessionPlugins[sessionId];\n    }\n\n    if (_.isEmpty(this.sessionlessPlugins)) {\n      this.sessionlessPlugins = this.createPluginInstances();\n    }\n    return this.sessionlessPlugins;\n  }\n\n  /**\n   * To get plugins for a command, we either get the plugin instances associated with the\n   * particular command's session, or in the case of sessionless plugins, pull from the set of\n   * plugin instances reserved for sessionless commands (and we lazily create plugin instances on\n   * first use)\n   *\n   * @param {string} cmd - the name of the command to find a plugin to handle\n   * @param {?string} sessionId - the particular session for which to find a plugin, or null if\n   * sessionless\n   */\n  pluginsToHandleCmd(cmd, sessionId = null) {\n    // to handle a given command, a plugin should either implement that command as a plugin\n    // instance method or it should implement a generic 'handle' method\n    return this.pluginsForSession(sessionId).filter(\n      (p) => _.isFunction(p[cmd]) || _.isFunction(p.handle)\n    );\n  }\n\n  /**\n   * Creates instances of all of the enabled Plugin classes\n   * @returns {Plugin[]}\n   */\n  createPluginInstances() {\n    /** @type {Plugin[]} */\n    const pluginInstances = [];\n    for (const [PluginClass, name] of this.pluginClasses.entries()) {\n      const cliArgs = this.getCliArgsForPlugin(name);\n      const plugin = new PluginClass(name, cliArgs);\n      pluginInstances.push(plugin);\n    }\n    return pluginInstances;\n  }\n\n  /**\n   *\n   * @param {string} cmd\n   * @param  {...any} args\n   * @returns {Promise<{value: any, error?: Error, protocol: string} | import('type-fest').AsyncReturnType<Driver['executeCommand']>>}\n   */\n  async executeCommand(cmd, ...args) {\n    // We have basically three cases for how to handle commands:\n    // 1. handle getStatus (we do this as a special out of band case so it doesn't get added to an\n    //    execution queue, and can be called while e.g. createSession is in progress)\n    // 2. handle commands that this umbrella driver should handle, rather than the actual session\n    //    driver (for example, deleteSession, or other non-session commands)\n    // 3. handle session driver commands.\n    // The tricky part is that because we support command plugins, we need to wrap any of these\n    // cases with plugin handling.\n\n    const isGetStatus = cmd === GET_STATUS_COMMAND;\n    const isUmbrellaCmd = isAppiumDriverCommand(cmd);\n    const isSessionCmd = isSessionCommand(cmd);\n\n    // if a plugin override proxying for this command and that is why we are here instead of just\n    // letting the protocol proxy the command entirely, determine that, get the request object for\n    // use later on, then clean up the args\n    const reqForProxy = _.last(args)?.reqForProxy;\n    if (reqForProxy) {\n      args.pop();\n    }\n\n    // first do some error checking. If we're requesting a session command execution, then make\n    // sure that session actually exists on the session driver, and set the session driver itself\n    let sessionId = null;\n    let dstSession = null;\n    let protocol = null;\n    /** @type {this | ExternalDriver} */\n    let driver = this;\n    if (isSessionCmd) {\n      sessionId = _.last(args);\n      dstSession = this.sessions[sessionId];\n      if (!dstSession) {\n        throw new Error(`The session with id '${sessionId}' does not exist`);\n      }\n      // now save the response protocol given that the session driver's protocol might differ\n      protocol = dstSession.protocol;\n      if (!isUmbrellaCmd) {\n        driver = dstSession;\n      }\n    }\n\n    // get any plugins which are registered as handling this command\n    const plugins = this.pluginsToHandleCmd(cmd, sessionId);\n\n    // now we define a 'cmdHandledBy' object which will keep track of which plugins have handled this\n    // command. we care about this because (a) multiple plugins can handle the same command, and\n    // (b) there's no guarantee that a plugin will actually call the next() method which runs the\n    // original command execution. This results in a situation where the command might be handled\n    // by some but not all plugins, or by plugin(s) but not by the default behavior. So start out\n    // this object declaring that the default handler has not been executed.\n    const cmdHandledBy = {default: false};\n\n    // now we define an async function which will be passed to plugins, and successively wrapped\n    // if there is more than one plugin that can handle the command. To start off with, the async\n    // function is defined as calling the default behavior, i.e., whichever of the 3 cases above is\n    // the appropriate one\n    const defaultBehavior = async () => {\n      // if we're running with plugins, make sure we log that the default behavior is actually\n      // happening so we can tell when the plugin call chain is unwrapping to the default behavior\n      // if that's what happens\n      plugins.length && this.log.info(`Executing default handling behavior for command '${cmd}'`);\n\n      // if we make it here, we know that the default behavior is handled\n      cmdHandledBy.default = true;\n\n      if (reqForProxy) {\n        // we would have proxied this command had a plugin not handled it, so the default behavior\n        // is to do the proxy and retrieve the result internally so it can be passed to the plugin\n        // in case it calls 'await next()'. This requires that the driver have defined\n        // 'proxyCommand' and not just 'proxyReqRes'.\n        if (!dstSession.proxyCommand) {\n          throw new NoDriverProxyCommandError();\n        }\n        return await dstSession.proxyCommand(\n          reqForProxy.originalUrl,\n          reqForProxy.method,\n          reqForProxy.body\n        );\n      }\n\n      if (isGetStatus) {\n        return await this.getStatus();\n      }\n\n      if (isUmbrellaCmd) {\n        // some commands, like deleteSession, we want to make sure to handle on *this* driver,\n        // not the platform driver\n        return await BaseDriver.prototype.executeCommand.call(this, cmd, ...args);\n      }\n\n      // here we know that we are executing a session command, and have a valid session driver\n      return await dstSession.executeCommand(cmd, ...args);\n    };\n\n    // now take our default behavior, wrap it with any number of plugin behaviors, and run it\n    const wrappedCmd = this.wrapCommandWithPlugins({\n      driver,\n      cmd,\n      args,\n      plugins,\n      cmdHandledBy,\n      next: defaultBehavior,\n    });\n    const res = await this.executeWrappedCommand({wrappedCmd, protocol});\n\n    // if we had plugins, make sure to log out the helpful report about which plugins ended up\n    // handling the command and which didn't\n    this.logPluginHandlerReport(plugins, {cmd, cmdHandledBy});\n\n    // And finally, if the command was createSession, we want to migrate any plugins which were\n    // previously sessionless to use the new sessionId, so that plugins can share state between\n    // their createSession method and other instance methods\n    if (cmd === CREATE_SESSION_COMMAND && this.sessionlessPlugins.length && !res.error) {\n      const sessionId = _.first(res.value);\n      this.log.info(\n        `Promoting ${this.sessionlessPlugins.length} sessionless plugins to be attached ` +\n          `to session ID ${sessionId}`\n      );\n      this.sessionPlugins[sessionId] = this.sessionlessPlugins;\n      this.sessionlessPlugins = [];\n    }\n\n    return res;\n  }\n\n  wrapCommandWithPlugins({driver, cmd, args, next, cmdHandledBy, plugins}) {\n    plugins.length &&\n      this.log.info(`Plugins which can handle cmd '${cmd}': ${plugins.map((p) => p.name)}`);\n\n    // now we can go through each plugin and wrap `next` around its own handler, passing the *old*\n    // next in so that it can call it if it wants to\n    for (const plugin of plugins) {\n      // need an IIFE here because we want the value of next that's passed to plugin.handle to be\n      // exactly the value of next here before reassignment; we don't want it to be lazily\n      // evaluated, otherwise we end up with infinite recursion of the last `next` to be defined.\n      cmdHandledBy[plugin.name] = false; // we see a new plugin, so add it to the 'cmdHandledBy' object\n      next = ((_next) => async () => {\n        this.log.info(`Plugin ${plugin.name} is now handling cmd '${cmd}'`);\n        cmdHandledBy[plugin.name] = true; // if we make it here, this plugin has attempted to handle cmd\n        // first attempt to handle the command via a command-specific handler on the plugin\n        if (plugin[cmd]) {\n          return await plugin[cmd](_next, driver, ...args);\n        }\n        // otherwise, call the generic 'handle' method\n        return await plugin.handle(_next, driver, cmd, ...args);\n      })(next);\n    }\n\n    return next;\n  }\n\n  logPluginHandlerReport(plugins, {cmd, cmdHandledBy}) {\n    if (!plugins.length) {\n      return;\n    }\n\n    // at the end of the day, we have an object representing which plugins ended up getting\n    // their code run as part of handling this command. Because plugins can choose *not* to\n    // pass control to other plugins or to the default driver behavior, this is information\n    // which is probably useful to the user (especially in situations where plugins might not\n    // interact well together, and it would be hard to debug otherwise without this kind of\n    // message).\n    const didHandle = Object.keys(cmdHandledBy).filter((k) => cmdHandledBy[k]);\n    const didntHandle = Object.keys(cmdHandledBy).filter((k) => !cmdHandledBy[k]);\n    if (didntHandle.length > 0) {\n      this.log.info(\n        `Command '${cmd}' was *not* handled by the following behaviours or plugins, even ` +\n          `though they were registered to handle it: ${JSON.stringify(didntHandle)}. The ` +\n          `command *was* handled by these: ${JSON.stringify(didHandle)}.`\n      );\n    }\n  }\n\n  async executeWrappedCommand({wrappedCmd, protocol}) {\n    let cmdRes,\n      cmdErr,\n      res = {};\n    try {\n      // At this point, `wrappedCmd` defines a whole sequence of plugin handlers, culminating in\n      // our default handler. Whatever it returns is what we're going to want to send back to the\n      // user.\n      cmdRes = await wrappedCmd();\n    } catch (e) {\n      cmdErr = e;\n    }\n\n    // Sadly, we don't know exactly what kind of object will be returned. It will either be a bare\n    // object, or a protocol-aware object with protocol and error/value keys. So we need to sniff\n    // it and make sure we don't double-wrap it if it's the latter kind.\n    if (_.isPlainObject(cmdRes) && _.has(cmdRes, 'protocol')) {\n      res = cmdRes;\n    } else {\n      res.value = cmdRes;\n      res.error = cmdErr;\n      res.protocol = protocol;\n    }\n    return res;\n  }\n\n  proxyActive(sessionId) {\n    const dstSession = this.sessions[sessionId];\n    return dstSession && _.isFunction(dstSession.proxyActive) && dstSession.proxyActive(sessionId);\n  }\n\n  /**\n   *\n   * @param {string} sessionId\n   * @returns {import('@appium/types').RouteMatcher[]}\n   */\n  getProxyAvoidList(sessionId) {\n    const dstSession = this.sessions[sessionId];\n    return dstSession ? dstSession.getProxyAvoidList() : [];\n  }\n\n  canProxy(sessionId) {\n    const dstSession = this.sessions[sessionId];\n    return dstSession && dstSession.canProxy(sessionId);\n  }\n}\n\n// help decide which commands should be proxied to sub-drivers and which\n// should be handled by this, our umbrella driver\nfunction isAppiumDriverCommand(cmd) {\n  return !isSessionCommand(cmd) || cmd === DELETE_SESSION_COMMAND;\n}\n\n/**\n * Thrown when Appium tried to proxy a command using a driver's `proxyCommand` method but the\n * method did not exist\n */\nexport class NoDriverProxyCommandError extends Error {\n  /**\n   * @type {Readonly<string>}\n   */\n  code = 'APPIUMERR_NO_DRIVER_PROXYCOMMAND';\n\n  constructor() {\n    super(\n      `The default behavior for this command was to proxy, but the driver ` +\n        `did not have the 'proxyCommand' method defined. To fully support ` +\n        `plugins, drivers should have 'proxyCommand' set to a jwpProxy object's ` +\n        `'command()' method, in addition to the normal 'proxyReqRes'`\n    );\n  }\n}\n\nexport {AppiumDriver};\n\n/**\n * @typedef {import('@appium/types').ExternalDriver} ExternalDriver\n * @typedef {import('@appium/types').Driver} Driver\n * @typedef {import('@appium/types').DriverClass} DriverClass\n * @typedef {import('@appium/types').DriverData} DriverData\n * @typedef {import('@appium/types').ServerArgs} DriverOpts\n * @typedef {import('@appium/types').Constraints} Constraints\n * @typedef {import('@appium/types').AppiumServer} AppiumServer\n * @typedef {import('@appium/types').ExtensionType} ExtensionType\n * @typedef {import('./extension/driver-config').DriverConfig} DriverConfig\n * @typedef {import('@appium/types').Plugin} Plugin\n * @typedef {import('@appium/types').PluginClass} PluginClass\n * @typedef {import('@appium/types').PluginType} PluginType\n * @typedef {import('@appium/types').DriverType} DriverType\n * @typedef {import('@appium/types').StringRecord} StringRecord\n * @typedef {import('@appium/types').SessionHandler<SessionHandlerResult<any[]>,SessionHandlerResult<void>>} SessionHandler\n */\n\n/**\n * Used by {@linkcode AppiumDriver.createSession} and {@linkcode AppiumDriver.deleteSession} to describe\n * result.\n * @template V\n * @typedef SessionHandlerResult\n * @property {V} [value]\n * @property {Error} [error]\n * @property {string} [protocol]\n */\n\n/**\n * @template {Constraints} C\n * @typedef {import('@appium/types').W3CCapabilities<C>} W3CCapabilities\n */\n\n/**\n * @template {Constraints} C\n * @typedef {import('@appium/types').Capabilities<C>} Capabilities\n */\n"],"mappings":"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"}