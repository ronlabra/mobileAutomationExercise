{"version":3,"file":"extension-command.js","names":["UPDATE_ALL","NotUpdatableError","Error","NoUpdatesAvailableError","ExtensionCommand","config","knownExtensions","isJsonOutput","constructor","json","log","console","CliConsole","jsonMode","Boolean","type","extensionType","_createFatalError","message","decorate","execute","args","cmd","_","isFunction","executeCmd","bind","list","showInstalled","showUpdates","lsMsg","installedNames","Object","keys","installedExtensions","knownNames","exts","reduce","acc","name","includes","installed","pkgName","spinWith","ext","data","toPairs","installType","INSTALL_TYPE_NPM","updates","checkForExtensionUpdate","updateVersion","safeUpdate","unsafeUpdateVersion","unsafeUpdate","upToDate","listData","installTxt","grey","updateTxt","upToDateTxt","unsafeUpdateTxt","installSpec","version","typeTxt","INSTALL_TYPE_GIT","INSTALL_TYPE_GITHUB","yellow","INSTALL_TYPE_LOCAL","magenta","green","cyan","_install","packageName","extData","installOpts","probableExtName","split","length","replace","pkgVer","path","isAbsolute","resolve","splits","msg","JSON","stringify","isInstalled","installViaNpm","extName","extManifest","errors","warnings","B","all","getProblems","getWarnings","errorMap","Map","warningMap","errorSummaries","warningSummaries","getValidationResultSummaries","isEmpty","join","warn","addExtension","env","hasAppiumDependency","appiumHome","packageDidChange","info","getPostInstallText","npmSpec","specMsg","pkgJsonData","npm","installPackage","validatePackageJson","getExtensionFields","err","pkgJson","appium","peerDependencies","result","appiumVersion","createMissingFieldError","field","ReferenceError","validateExtensionFields","extMetadata","_uninstall","uninstallPackage","removeExtension","ok","_update","unsafe","shouldUpdateAll","extsToUpdate","e","update","current","updateVer","updateExtension","from","to","error","red","getLatestVersion","getLatestSafeUpgradeVersion","util","compareVersions","_run","scriptName","extraArgs","extConfig","scripts","extScripts","isPlainObject","has","runner","SubProcess","process","execPath","cwd","getInstallPath","output","RingBuffer","on","line","enqueue","start","getBuff"],"sources":["../../../lib/cli/extension-command.js"],"sourcesContent":["/* eslint-disable no-console */\nimport B from 'bluebird';\nimport _ from 'lodash';\nimport path from 'path';\nimport {npm, util, env, console} from '@appium/support';\nimport {spinWith, RingBuffer} from './utils';\nimport {SubProcess} from 'teen_process';\nimport {\n  INSTALL_TYPE_NPM,\n  INSTALL_TYPE_GIT,\n  INSTALL_TYPE_GITHUB,\n  INSTALL_TYPE_LOCAL,\n} from '../extension/extension-config';\nimport {packageDidChange} from '../extension/package-changed';\n\nconst UPDATE_ALL = 'installed';\n\nclass NotUpdatableError extends Error {}\nclass NoUpdatesAvailableError extends Error {}\n\n/**\n * @template {ExtensionType} ExtType\n */\nclass ExtensionCommand {\n  /**\n   * This is the `DriverConfig` or `PluginConfig`, depending on `ExtType`.\n   * @type {ExtensionConfig<ExtType>}\n   */\n  config;\n\n  /**\n   * {@linkcode Record} of official plugins or drivers.\n   * @type {KnownExtensions<ExtType>}\n   */\n  knownExtensions;\n\n  /**\n   * If `true`, command output has been requested as JSON.\n   * @type {boolean}\n   */\n  isJsonOutput;\n\n  /**\n   * Build an ExtensionCommand\n   * @param {ExtensionCommandOptions<ExtType>} opts\n   */\n  constructor({config, json}) {\n    this.config = config;\n    this.log = new console.CliConsole({jsonMode: json});\n    this.isJsonOutput = Boolean(json);\n  }\n\n  /**\n   * `driver` or `plugin`, depending on the `ExtensionConfig`.\n   */\n  get type() {\n    return this.config.extensionType;\n  }\n\n  /**\n   * Logs a message and returns an {@linkcode Error} to throw.\n   *\n   * For TS to understand that a function throws an exception, it must actually throw an exception--\n   * in other words, _calling_ a function which is guaranteed to throw an exception is not enough--\n   * nor is something like `@returns {never}` which does not imply a thrown exception.\n   * @param {string} message\n   * @protected\n   * @returns {Error}\n   */\n  _createFatalError(message) {\n    return new Error(this.log.decorate(message, 'error'));\n  }\n\n  /**\n   * Take a CLI parse and run an extension command based on its type\n   *\n   * @param {object} args - a key/value object with CLI flags and values\n   * @return {Promise<object>} the result of the specific command which is executed\n   */\n  async execute(args) {\n    const cmd = args[`${this.type}Command`];\n    if (!_.isFunction(this[cmd])) {\n      throw this._createFatalError(`Cannot handle ${this.type} command ${cmd}`);\n    }\n    const executeCmd = this[cmd].bind(this);\n    return await executeCmd(args);\n  }\n\n  /**\n   * List extensions\n   *\n   * @param {ListOptions} opts\n   * @return {Promise<ExtensionListData>} map of extension names to extension data\n   */\n  async list({showInstalled, showUpdates}) {\n    const lsMsg = `Listing ${showInstalled ? 'installed' : 'available'} ${this.type}s`;\n    const installedNames = Object.keys(this.config.installedExtensions);\n    const knownNames = Object.keys(this.knownExtensions);\n    const exts = [...installedNames, ...knownNames].reduce(\n      (acc, name) => {\n        if (!acc[name]) {\n          if (installedNames.includes(name)) {\n            acc[name] = {\n              ...this.config.installedExtensions[name],\n              installed: true,\n            };\n          } else if (!showInstalled) {\n            acc[name] = {pkgName: this.knownExtensions[name], installed: false};\n          }\n        }\n        return acc;\n      },\n      /**\n       * This accumulator contains either {@linkcode UninstalledExtensionLIstData} _or_\n       * {@linkcode InstalledExtensionListData} without upgrade information (which is added by the below code block)\n       * @type {Record<string,Partial<InstalledExtensionListData>|UninstalledExtensionListData>}\n       */ ({})\n    );\n\n    // if we want to show whether updates are available, put that behind a spinner\n    await spinWith(this.isJsonOutput, lsMsg, async () => {\n      if (!showUpdates) {\n        return;\n      }\n      for (const [ext, data] of _.toPairs(exts)) {\n        if (!data.installed || data.installType !== INSTALL_TYPE_NPM) {\n          // don't need to check for updates on exts that aren't installed\n          // also don't need to check for updates on non-npm exts\n          continue;\n        }\n        const updates = await this.checkForExtensionUpdate(ext);\n        data.updateVersion = updates.safeUpdate;\n        data.unsafeUpdateVersion = updates.unsafeUpdate;\n        data.upToDate = updates.safeUpdate === null && updates.unsafeUpdate === null;\n      }\n    });\n\n    const listData = /** @type {ExtensionListData} */ (exts);\n\n    // if we're just getting the data, short circuit return here since we don't need to do any\n    // formatting logic\n    if (this.isJsonOutput) {\n      return listData;\n    }\n\n    for (const [name, data] of _.toPairs(listData)) {\n      let installTxt = ' [not installed]'.grey;\n      let updateTxt = '';\n      let upToDateTxt = '';\n      let unsafeUpdateTxt = '';\n      if (data.installed) {\n        const {installType, installSpec, updateVersion, unsafeUpdateVersion, version, upToDate} =\n          data;\n        let typeTxt;\n        switch (installType) {\n          case INSTALL_TYPE_GIT:\n          case INSTALL_TYPE_GITHUB:\n            typeTxt = `(cloned from ${installSpec})`.yellow;\n            break;\n          case INSTALL_TYPE_LOCAL:\n            typeTxt = `(linked from ${installSpec})`.magenta;\n            break;\n          default:\n            typeTxt = '(NPM)';\n        }\n        installTxt = `@${version.yellow} ${('[installed ' + typeTxt + ']').green}`;\n\n        if (showUpdates) {\n          if (updateVersion) {\n            updateTxt = ` [${updateVersion} available]`.magenta;\n          }\n          if (upToDate) {\n            upToDateTxt = ` [Up to date]`.green;\n          }\n          if (unsafeUpdateVersion) {\n            unsafeUpdateTxt = ` [${unsafeUpdateVersion} available (potentially unsafe)]`.cyan;\n          }\n        }\n      }\n\n      this.log.log(`- ${name.yellow}${installTxt}${updateTxt}${upToDateTxt}${unsafeUpdateTxt}`);\n    }\n\n    return listData;\n  }\n\n  /**\n   * Install an extension\n   *\n   * @param {InstallArgs} args\n   * @return {Promise<ExtRecord<ExtType>>} map of all installed extension names to extension data\n   */\n  async _install({installSpec, installType, packageName}) {\n    /** @type {ExtensionFields<ExtType>} */\n    let extData;\n\n    if (packageName && [INSTALL_TYPE_LOCAL, INSTALL_TYPE_NPM].includes(installType)) {\n      throw this._createFatalError(`When using --source=${installType}, cannot also use --package`);\n    }\n\n    if (!packageName && [INSTALL_TYPE_GIT, INSTALL_TYPE_GITHUB].includes(installType)) {\n      throw this._createFatalError(`When using --source=${installType}, must also use --package`);\n    }\n\n    /**\n     * @type {InstallViaNpmArgs}\n     */\n    let installOpts;\n\n    /**\n     * The probable (?) name of the extension derived from the install spec.\n     *\n     * If using a local install type, this will remain empty.\n     * @type {string}\n     */\n    let probableExtName = '';\n\n    // depending on `installType`, build the options to pass into `installViaNpm`\n    if (installType === INSTALL_TYPE_GITHUB) {\n      if (installSpec.split('/').length !== 2) {\n        throw this._createFatalError(\n          `Github ${this.type} spec ${installSpec} appeared to be invalid; ` +\n            'it should be of the form <org>/<repo>'\n        );\n      }\n      installOpts = {\n        installSpec,\n        pkgName: /** @type {string} */ (packageName),\n      };\n      probableExtName = installSpec;\n    } else if (installType === INSTALL_TYPE_GIT) {\n      // git urls can have '.git' at the end, but this is not necessary and would complicate the\n      // way we download and name directories, so we can just remove it\n      installSpec = installSpec.replace(/\\.git$/, '');\n      installOpts = {\n        installSpec,\n        pkgName: /** @type {string} */ (packageName),\n      };\n      probableExtName = installSpec;\n    } else {\n      let pkgName, pkgVer;\n      if (installType === INSTALL_TYPE_LOCAL) {\n        pkgName = path.isAbsolute(installSpec) ? installSpec : path.resolve(installSpec);\n      } else {\n        // at this point we have either an npm package or an appium verified extension\n        // name or a local path. both of which will be installed via npm.\n        // extensions installed via npm can include versions or tags after the '@'\n        // sign, so check for that. We also need to be careful that package names themselves can\n        // contain the '@' symbol, as in `npm install @appium/fake-driver@1.2.0`\n        let name;\n        const splits = installSpec.split('@');\n        if (installSpec[0] === '@') {\n          // this is the case where we have an npm org included in the package name\n          [name, pkgVer] = [`@${splits[1]}`, splits[2]];\n        } else {\n          // this is the case without an npm org\n          [name, pkgVer] = splits;\n        }\n\n        if (installType === INSTALL_TYPE_NPM) {\n          // if we're installing a named package from npm, we don't need to check\n          // against the appium extension list; just use the installSpec as is\n          pkgName = name;\n        } else {\n          // if we're installing a named appium driver (like 'xcuitest') we need to\n          // dereference the actual npm package ('appiupm-xcuitest-driver'), so\n          // check it exists and get the correct package\n          const knownNames = Object.keys(this.knownExtensions);\n          if (!_.includes(knownNames, name)) {\n            const msg =\n              `Could not resolve ${this.type}; are you sure it's in the list ` +\n              `of supported ${this.type}s? ${JSON.stringify(knownNames)}`;\n            throw this._createFatalError(msg);\n          }\n          probableExtName = name;\n          pkgName = this.knownExtensions[name];\n          // given that we'll use the install type in the driver json, store it as\n          // 'npm' now\n          installType = INSTALL_TYPE_NPM;\n        }\n      }\n      installOpts = {installSpec, pkgName, pkgVer};\n    }\n\n    // fail fast here if we can\n    if (probableExtName && this.config.isInstalled(probableExtName)) {\n      throw this._createFatalError(\n        `A ${this.type} named \"${probableExtName}\" is already installed. ` +\n          `Did you mean to update? Run \"appium ${this.type} update\". See ` +\n          `installed ${this.type}s with \"appium ${this.type} list --installed\".`\n      );\n    }\n\n    extData = await this.installViaNpm(installOpts);\n\n    // this _should_ be the same as `probablyExtName` as the one derived above unless\n    // install type is local.\n    const extName = extData[/** @type {string} */ (`${this.type}Name`)];\n\n    // check _a second time_ with the more-accurate extName\n    if (this.config.isInstalled(extName)) {\n      throw this._createFatalError(\n        `A ${this.type} named \"${extName}\" is already installed. ` +\n          `Did you mean to update? Run \"appium ${this.type} update\". See ` +\n          `installed ${this.type}s with \"appium ${this.type} list --installed\".`\n      );\n    }\n\n    // this field does not exist as such in the manifest (it's used as a property name instead)\n    // so that's why it's being removed here.\n    delete extData[/** @type {string} */ (`${this.type}Name`)];\n\n    /** @type {ExtManifest<ExtType>} */\n    const extManifest = {...extData, installType, installSpec};\n    const [errors, warnings] = await B.all([\n      this.config.getProblems(extName, extManifest),\n      this.config.getWarnings(extName, extManifest),\n    ]);\n    const errorMap = new Map([[extName, errors]]);\n    const warningMap = new Map([[extName, warnings]]);\n    const {errorSummaries, warningSummaries} = this.config.getValidationResultSummaries(\n      errorMap,\n      warningMap\n    );\n\n    if (!_.isEmpty(errorSummaries)) {\n      throw this._createFatalError(errorSummaries.join('\\n'));\n    }\n\n    // note that we won't show any warnings if there were errors.\n    if (!_.isEmpty(warningSummaries)) {\n      this.log.warn(warningSummaries.join('\\n'));\n    }\n\n    await this.config.addExtension(extName, extManifest);\n\n    // update the if we've changed the local `package.json`\n    if (await env.hasAppiumDependency(this.config.appiumHome)) {\n      await packageDidChange(this.config.appiumHome);\n    }\n\n    // log info for the user\n    this.log.info(this.getPostInstallText({extName, extData}));\n\n    return this.config.installedExtensions;\n  }\n\n  /**\n   * Install an extension via NPM\n   *\n   * @param {InstallViaNpmArgs} args\n   */\n  async installViaNpm({installSpec, pkgName, pkgVer}) {\n    const npmSpec = `${pkgName}${pkgVer ? '@' + pkgVer : ''}`;\n    const specMsg = npmSpec === installSpec ? '' : ` using NPM install spec '${npmSpec}'`;\n    const msg = `Installing '${installSpec}'${specMsg}`;\n    try {\n      const pkgJsonData = await spinWith(this.isJsonOutput, msg, async () => {\n        const pkgJsonData = await npm.installPackage(this.config.appiumHome, pkgName, {\n          pkgVer,\n        });\n        this.validatePackageJson(pkgJsonData, installSpec);\n        return pkgJsonData;\n      });\n\n      return this.getExtensionFields(pkgJsonData);\n    } catch (err) {\n      throw this._createFatalError(`Encountered an error when installing package: ${err.message}`);\n    }\n  }\n\n  /**\n   * Get the text which should be displayed to the user after an extension has been installed. This\n   * is designed to be overridden by drivers/plugins with their own particular text.\n   *\n   * @param {ExtensionArgs} args\n   * @returns {string}\n   */\n  // eslint-disable-next-line no-unused-vars\n  getPostInstallText(args) {\n    throw this._createFatalError('Must be implemented in final class');\n  }\n\n  /**\n   * Take an NPM module's package.json and extract Appium driver information from a special\n   * 'appium' field in the JSON data. We need this information to e.g. determine which class to\n   * load as the main driver class, or to be able to detect incompatibilities between driver and\n   * appium versions.\n   *\n   * @param {ExtPackageJson<ExtType>} pkgJson - the package.json data for a driver module, as if it had been straightforwardly 'require'd\n   * @returns {ExtensionFields<ExtType>}\n   */\n  getExtensionFields(pkgJson) {\n    const {appium, name, version, peerDependencies} = pkgJson;\n\n    /** @type {unknown} */\n    const result = {\n      ...appium,\n      pkgName: name,\n      version,\n      appiumVersion: peerDependencies?.appium,\n    };\n    return /** @type {ExtensionFields<ExtType>} */ (result);\n  }\n\n  /**\n   * Validates the _required_ root fields of an extension's `package.json` file.\n   *\n   * These required fields are:\n   * - `name`\n   * - `version`\n   * - `appium`\n   * @param {import('type-fest').PackageJson} pkgJson - `package.json` of extension\n   * @param {string} installSpec - Extension name/spec\n   * @throws {ReferenceError} If `package.json` has a missing or invalid field\n   * @returns {pkgJson is ExtPackageJson<ExtType>}\n   */\n  validatePackageJson(pkgJson, installSpec) {\n    const {appium, name, version} = /** @type {ExtPackageJson<ExtType>} */ (pkgJson);\n\n    /**\n     *\n     * @param {string} field\n     * @returns {ReferenceError}\n     */\n    const createMissingFieldError = (field) =>\n      new ReferenceError(\n        `${this.type} \"${installSpec}\" invalid; missing a \\`${field}\\` field of its \\`package.json\\``\n      );\n\n    if (!name) {\n      throw createMissingFieldError('name');\n    }\n    if (!version) {\n      throw createMissingFieldError('version');\n    }\n    if (!appium) {\n      throw createMissingFieldError('appium');\n    }\n\n    this.validateExtensionFields(appium, installSpec);\n\n    return true;\n  }\n\n  /**\n   * For any `package.json` fields which a particular type of extension requires, validate the\n   * presence and form of those fields on the `package.json` data, throwing an error if anything is\n   * amiss.\n   *\n   * @param {ExtMetadata<ExtType>} extMetadata - the data in the \"appium\" field of `package.json` for an extension\n   * @param {string} installSpec - Extension name/spec\n   */\n  // eslint-disable-next-line no-unused-vars\n  validateExtensionFields(extMetadata, installSpec) {\n    throw this._createFatalError('Must be implemented in final class');\n  }\n\n  /**\n   * Uninstall an extension.\n   *\n   * First tries to do this via `npm uninstall`, but if that fails, just `rm -rf`'s the extension dir.\n   *\n   * Will only remove the extension from the manifest if it has been successfully removed.\n   *\n   * @param {UninstallOpts} opts\n   * @return {Promise<ExtRecord<ExtType>>} map of all installed extension names to extension data (without the extension just uninstalled)\n   */\n  async _uninstall({installSpec}) {\n    if (!this.config.isInstalled(installSpec)) {\n      throw this._createFatalError(\n        `Can't uninstall ${this.type} '${installSpec}'; it is not installed`\n      );\n    }\n    const pkgName = this.config.installedExtensions[installSpec].pkgName;\n    await npm.uninstallPackage(this.config.appiumHome, pkgName);\n    await this.config.removeExtension(installSpec);\n    this.log.ok(`Successfully uninstalled ${this.type} '${installSpec}'`.green);\n    return this.config.installedExtensions;\n  }\n\n  /**\n   * Attempt to update one or more drivers using NPM\n   *\n   * @param {ExtensionUpdateOpts} updateSpec\n   * @return {Promise<ExtensionUpdateResult>}\n   */\n  async _update({installSpec, unsafe}) {\n    const shouldUpdateAll = installSpec === UPDATE_ALL;\n    // if we're specifically requesting an update for an extension, make sure it's installed\n    if (!shouldUpdateAll && !this.config.isInstalled(installSpec)) {\n      throw this._createFatalError(\n        `The ${this.type} \"${installSpec}\" was not installed, so can't be updated`\n      );\n    }\n    const extsToUpdate = shouldUpdateAll\n      ? Object.keys(this.config.installedExtensions)\n      : [installSpec];\n\n    // 'errors' will have ext names as keys and error objects as values\n    /** @type {Record<string,Error>} */\n    const errors = {};\n\n    // 'updates' will have ext names as keys and update objects as values, where an update\n    // object is of the form {from: versionString, to: versionString}\n    /** @type {Record<string,UpdateReport>} */\n    const updates = {};\n\n    for (const e of extsToUpdate) {\n      try {\n        await spinWith(this.isJsonOutput, `Checking if ${this.type} '${e}' is updatable`, () => {\n          if (this.config.installedExtensions[e].installType !== INSTALL_TYPE_NPM) {\n            throw new NotUpdatableError();\n          }\n        });\n        const update = await spinWith(\n          this.isJsonOutput,\n          `Checking if ${this.type} '${e}' needs an update`,\n          async () => {\n            const update = await this.checkForExtensionUpdate(e);\n            if (!(update.safeUpdate || update.unsafeUpdate)) {\n              throw new NoUpdatesAvailableError();\n            }\n            return update;\n          }\n        );\n        if (!unsafe && !update.safeUpdate) {\n          throw this._createFatalError(\n            `The ${this.type} '${e}' has a major revision update ` +\n              `(${update.current} => ${update.unsafeUpdate}), which could include ` +\n              `breaking changes. If you want to apply this update, re-run with --unsafe`\n          );\n        }\n        const updateVer = unsafe && update.unsafeUpdate ? update.unsafeUpdate : update.safeUpdate;\n        await spinWith(\n          this.isJsonOutput,\n          `Updating driver '${e}' from ${update.current} to ${updateVer}`,\n          async () => await this.updateExtension(e, updateVer)\n        );\n        updates[e] = {from: update.current, to: updateVer};\n      } catch (err) {\n        errors[e] = err;\n      }\n    }\n\n    this.log.info('Update report:');\n\n    for (const [e, update] of _.toPairs(updates)) {\n      this.log.ok(`  - ${this.type} ${e} updated: ${update.from} => ${update.to}`.green);\n    }\n\n    for (const [e, err] of _.toPairs(errors)) {\n      if (err instanceof NotUpdatableError) {\n        this.log.warn(\n          `  - '${e}' was not installed via npm, so we could not check ` + `for updates`.yellow\n        );\n      } else if (err instanceof NoUpdatesAvailableError) {\n        this.log.info(`  - '${e}' had no updates available`.yellow);\n      } else {\n        // otherwise, make it pop with red!\n        this.log.error(`  - '${e}' failed to update: ${err}`.red);\n      }\n    }\n    return {updates, errors};\n  }\n\n  /**\n   * Given an extension name, figure out what its highest possible version upgrade is, and also the\n   * highest possible safe upgrade.\n   *\n   * @param {string} ext - name of extension\n   * @return {Promise<PossibleUpdates>}\n   */\n  async checkForExtensionUpdate(ext) {\n    // TODO decide how we want to handle beta versions?\n    // this is a helper method, 'ext' is assumed to already be installed here, and of the npm\n    // install type\n    const {version, pkgName} = this.config.installedExtensions[ext];\n    /** @type {string?} */\n    let unsafeUpdate = await npm.getLatestVersion(this.config.appiumHome, pkgName);\n    let safeUpdate = await npm.getLatestSafeUpgradeVersion(\n      this.config.appiumHome,\n      pkgName,\n      version\n    );\n    if (unsafeUpdate !== null && !util.compareVersions(unsafeUpdate, '>', version)) {\n      // the latest version is not greater than the current version, so there's no possible update\n      unsafeUpdate = null;\n      safeUpdate = null;\n    }\n    if (unsafeUpdate && unsafeUpdate === safeUpdate) {\n      // the latest update is the same as the safe update, which means it's not actually unsafe\n      unsafeUpdate = null;\n    }\n    if (safeUpdate && !util.compareVersions(safeUpdate, '>', version)) {\n      // even the safe update is not later than the current, so it is not actually an update\n      safeUpdate = null;\n    }\n    return {current: version, safeUpdate, unsafeUpdate};\n  }\n\n  /**\n   * Actually update an extension installed by NPM, using the NPM cli. And update the installation\n   * manifest.\n   *\n   * @param {string} installSpec - name of extension to update\n   * @param {string} version - version string identifier to update extension to\n   * @returns {Promise<void>}\n   */\n  async updateExtension(installSpec, version) {\n    const {pkgName} = this.config.installedExtensions[installSpec];\n    const extData = await this.installViaNpm({\n      installSpec,\n      pkgName,\n      pkgVer: version,\n    });\n    delete extData[/** @type {string} */ (`${this.type}Name`)];\n    await this.config.updateExtension(installSpec, extData);\n  }\n\n  /**\n   * Runs a script cached inside the \"scripts\" field under \"appium\"\n   * inside of the driver/plugins \"package.json\" file. Will throw\n   * an error if the driver/plugin does not contain a \"scripts\" field\n   * underneath the \"appium\" field in its package.json, if the\n   * \"scripts\" field is not a plain object, or if the scriptName is\n   * not found within \"scripts\" object.\n   *\n   * @param {RunOptions} opts\n   * @return {Promise<RunOutput>}\n   */\n  async _run({installSpec, scriptName, extraArgs = []}) {\n    if (!this.config.isInstalled(installSpec)) {\n      throw this._createFatalError(`The ${this.type} \"${installSpec}\" is not installed`);\n    }\n\n    const extConfig = this.config.installedExtensions[installSpec];\n\n    // note: TS cannot understand that _.has() is a type guard\n    if (!extConfig.scripts) {\n      throw this._createFatalError(\n        `The ${this.type} named '${installSpec}' does not contain the ` +\n          `\"scripts\" field underneath the \"appium\" field in its package.json`\n      );\n    }\n\n    const extScripts = extConfig.scripts;\n\n    if (!_.isPlainObject(extScripts)) {\n      throw this._createFatalError(\n        `The ${this.type} named '${installSpec}' \"scripts\" field must be a plain object`\n      );\n    }\n\n    if (!_.has(extScripts, scriptName)) {\n      throw this._createFatalError(\n        `The ${this.type} named '${installSpec}' does not support the script: '${scriptName}'`\n      );\n    }\n\n    const runner = new SubProcess(process.execPath, [extScripts[scriptName], ...extraArgs], {\n      cwd: this.config.getInstallPath(installSpec),\n    });\n\n    const output = new RingBuffer(50);\n\n    runner.on('stream-line', (line) => {\n      output.enqueue(line);\n      this.log.log(line);\n    });\n\n    await runner.start(0);\n\n    try {\n      await runner.join();\n      this.log.ok(`${scriptName} successfully ran`.green);\n      return {output: output.getBuff()};\n    } catch (err) {\n      this.log.error(`Encountered an error when running '${scriptName}': ${err.message}`.red);\n      return {error: err.message, output: output.getBuff()};\n    }\n  }\n}\n\nexport default ExtensionCommand;\nexport {ExtensionCommand};\n\n/**\n * Options for the {@linkcode ExtensionCommand} constructor\n * @template {ExtensionType} ExtType\n * @typedef ExtensionCommandOptions\n * @property {ExtensionConfig<ExtType>} config - the `DriverConfig` or `PluginConfig` instance used for this command\n * @property {boolean} json - whether the output of this command should be JSON or text\n */\n\n/**\n * Extra stuff about extensions; used indirectly by {@linkcode ExtensionCommand.list}.\n *\n * @typedef ExtensionMetadata\n * @property {boolean} installed - If `true`, the extension is installed\n * @property {string?} updateVersion - If the extension is installed, the version it can be updated to\n * @property {string?} unsafeUpdateVersion - Same as above, but a major version bump\n * @property {boolean} upToDate - If the extension is installed and the latest\n */\n\n/**\n * @typedef {import('@appium/types').ExtensionType} ExtensionType\n * @typedef {import('@appium/types').DriverType} DriverType\n * @typedef {import('@appium/types').PluginType} PluginType\n */\n\n/**\n * @template {ExtensionType} ExtType\n * @typedef {import('appium/types').ExtRecord<ExtType>} ExtRecord\n */\n\n/**\n * @template {ExtensionType} ExtType\n * @typedef {import('../extension/extension-config').ExtensionConfig<ExtType>} ExtensionConfig\n */\n\n/**\n * @template {ExtensionType} ExtType\n * @typedef {import('appium/types').ExtMetadata<ExtType>} ExtMetadata\n */\n\n/**\n * @template {ExtensionType} ExtType\n * @typedef {import('appium/types').ExtManifest<ExtType>} ExtManifest\n */\n\n/**\n * @template {ExtensionType} ExtType\n * @typedef {import('appium/types').ExtPackageJson<ExtType>} ExtPackageJson\n */\n\n/**\n * Possible return value for {@linkcode ExtensionCommand.list}\n * @typedef UninstalledExtensionListData\n * @property {string} pkgName\n * @property {false} installed\n */\n\n/**\n * Possible return value for {@linkcode ExtensionCommand.list}\n * @typedef {import('appium/types').InternalMetadata & ExtensionMetadata} InstalledExtensionListData\n */\n\n/**\n * Return value of {@linkcode ExtensionCommand.list}.\n * @typedef {Record<string,InstalledExtensionListData|UninstalledExtensionListData>} ExtensionListData\n */\n\n/**\n * Options for {@linkcode ExtensionCommand._run}.\n * @typedef RunOptions\n * @property {string} installSpec - name of the extension to run a script from\n * @property {string} scriptName - name of the script to run\n * @property {string[]} [extraArgs] - arguments to pass to the script\n */\n\n/**\n * Return value of {@linkcode ExtensionCommand._run}\n *\n * @typedef RunOutput\n * @property {string} [error] - error message if script ran unsuccessfully, otherwise undefined\n * @property {string[]} output - script output\n */\n\n/**\n * Options for {@linkcode ExtensionCommand._update}.\n * @typedef ExtensionUpdateOpts\n * @property {string} installSpec - the name of the extension to update\n * @property {boolean} unsafe - if true, will perform unsafe updates past major revision boundaries\n */\n\n/**\n * Return value of {@linkcode ExtensionCommand._update}.\n * @typedef ExtensionUpdateResult\n * @property {Record<string,Error>} errors - map of ext names to error objects\n * @property {Record<string,UpdateReport>} updates - map of ext names to {@linkcode UpdateReport}s\n */\n\n/**\n * Part of result of {@linkcode ExtensionCommand._update}.\n * @typedef UpdateReport\n * @property {string} from - version the extension was updated from\n * @property {string} to - version the extension was updated to\n */\n\n/**\n * Options for {@linkcode ExtensionCommand._uninstall}.\n * @typedef UninstallOpts\n * @property {string} installSpec - the name or spec of an extension to uninstall\n */\n\n/**\n * Used by {@linkcode ExtensionCommand.getPostInstallText}\n * @typedef ExtensionArgs\n * @property {string} extName - the name of an extension\n * @property {object} extData - the data for an installed extension\n */\n\n/**\n * Options for {@linkcode ExtensionCommand.installViaNpm}\n * @typedef InstallViaNpmArgs\n * @property {string} installSpec - the name or spec of an extension to install\n * @property {string} pkgName - the NPM package name of the extension\n * @property {string} [pkgVer] - the specific version of the NPM package\n */\n\n/**\n * Object returned by {@linkcode ExtensionCommand.checkForExtensionUpdate}\n * @typedef PossibleUpdates\n * @property {string} current - current version\n * @property {string?} safeUpdate - version we can safely update to if it exists, or null\n * @property {string?} unsafeUpdate - version we can unsafely update to if it exists, or null\n */\n\n/**\n * Options for {@linkcode ExtensionCommand._install}\n * @typedef InstallArgs\n * @property {string} installSpec - the name or spec of an extension to install\n * @property {import('appium/types').InstallType} installType - how to install this extension. One of the INSTALL_TYPES\n * @property {string} [packageName] - for git/github installs, the extension node package name\n */\n\n/**\n * Returned by {@linkcode ExtensionCommand.getExtensionFields}\n * @template {ExtensionType} ExtType\n * @typedef {ExtMetadata<ExtType> & { pkgName: string, version: string, appiumVersion: string } & import('appium/types').CommonExtMetadata} ExtensionFields\n */\n\n/**\n * @template {ExtensionType} ExtType\n * @typedef {ExtType extends DriverType ? typeof import('../constants').KNOWN_DRIVERS : ExtType extends PluginType ? typeof import('../constants').KNOWN_PLUGINS : never} KnownExtensions\n */\n\n/**\n * @typedef ListOptions\n * @property {boolean} showInstalled - whether should show only installed extensions\n * @property {boolean} showUpdates - whether should show available updates\n */\n"],"mappings":"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"}