{"version":3,"file":"driver-config.js","names":["DriverConfig","ExtensionConfig","knownAutomationNames","_instances","WeakMap","constructor","manifest","DRIVER_TYPE","Set","create","instance","getInstance","Error","appiumHome","set","get","validate","clear","_validate","getExtensionData","getConfigProblems","extData","problems","platformNames","automationName","_","isArray","push","err","val","isEmpty","pName","isString","has","add","extensionDesc","driverName","version","findMatchingDriver","platformName","log","info","mainClass","_getDriverBySupport","getInstallPath","driver","require","msg","message","matchAutomationName","matchPlatformName","drivers","installedExtensions","driverData","toPairs","aNameMatches","toLowerCase","pNameMatches","includes","map","toLower","JSON","stringify"],"sources":["../../../lib/extension/driver-config.js"],"sourcesContent":["import _ from 'lodash';\nimport {DRIVER_TYPE} from '../constants';\nimport log from '../logger';\nimport {ExtensionConfig} from './extension-config';\n\n/**\n * @extends {ExtensionConfig<DriverType>}\n */\nexport class DriverConfig extends ExtensionConfig {\n  /**\n   * A set of unique automation names used by drivers.\n   * @type {Set<string>}\n   */\n  knownAutomationNames;\n\n  /**\n   * A mapping of {@link Manifest} instances to {@link DriverConfig} instances.\n   *\n   * `Manifest` and `ExtensionConfig` have a one-to-many relationship; each `Manifest` should be associated with a `DriverConfig` and a `PluginConfig`; no more, no less.\n   *\n   * This variable tracks the `Manifest`-to-`DriverConfig` portion.\n   *\n   * @type {WeakMap<Manifest,DriverConfig>}\n   * @private\n   */\n  static _instances = new WeakMap();\n\n  /**\n   * Call {@link DriverConfig.create} instead.\n   * @private\n   * @param {import('./manifest').Manifest} manifest - Manifest instance\n   */\n  constructor(manifest) {\n    super(DRIVER_TYPE, manifest);\n\n    this.knownAutomationNames = new Set();\n  }\n\n  /**\n   * Creates a new {@link DriverConfig} instance for a {@link Manifest} instance.\n   *\n   * @param {Manifest} manifest\n   * @throws If `manifest` already associated with a `DriverConfig`\n   * @returns {DriverConfig}\n   */\n  static create(manifest) {\n    const instance = new DriverConfig(manifest);\n    if (DriverConfig.getInstance(manifest)) {\n      throw new Error(\n        `Manifest with APPIUM_HOME ${manifest.appiumHome} already has a DriverConfig; use DriverConfig.getInstance() to retrieve it.`\n      );\n    }\n    DriverConfig._instances.set(manifest, instance);\n    return instance;\n  }\n\n  /**\n   * Returns a DriverConfig associated with a Manifest\n   * @param {Manifest} manifest\n   * @returns {DriverConfig|undefined}\n   */\n  static getInstance(manifest) {\n    return DriverConfig._instances.get(manifest);\n  }\n\n  /**\n   * Checks extensions for problems\n   */\n  async validate() {\n    this.knownAutomationNames.clear();\n    return await super._validate(this.manifest.getExtensionData(DRIVER_TYPE));\n  }\n\n  /**\n   * @param {ExtManifest<DriverType>} extData\n   * @returns {import('./extension-config').ExtManifestProblem[]}\n   */\n  getConfigProblems(extData) {\n    const problems = [];\n    const {platformNames, automationName} = extData;\n\n    if (!_.isArray(platformNames)) {\n      problems.push({\n        err: 'Missing or incorrect supported platformNames list.',\n        val: platformNames,\n      });\n    } else {\n      if (_.isEmpty(platformNames)) {\n        problems.push({\n          err: 'Empty platformNames list.',\n          val: platformNames,\n        });\n      } else {\n        for (const pName of platformNames) {\n          if (!_.isString(pName)) {\n            problems.push({\n              err: 'Incorrectly formatted platformName.',\n              val: pName,\n            });\n          }\n        }\n      }\n    }\n\n    if (!_.isString(automationName)) {\n      problems.push({\n        err: 'Missing or incorrect automationName',\n        val: automationName,\n      });\n    }\n\n    if (this.knownAutomationNames.has(automationName)) {\n      problems.push({\n        err: 'Multiple drivers claim support for the same automationName',\n        val: automationName,\n      });\n    }\n\n    // should we retain the name at the end of this function, once we've checked there are no problems?\n    this.knownAutomationNames.add(automationName);\n\n    return problems;\n  }\n\n  /**\n   * @param {ExtName<DriverType>} driverName\n   * @param {ExtManifest<DriverType>} extData\n   * @returns {string}\n   */\n  extensionDesc(driverName, {version, automationName}) {\n    return `${driverName}@${version} (automationName '${automationName}')`;\n  }\n\n  /**\n   * Given capabilities, find a matching driver within the config. Load its class and return it along with version and driver name.\n   * @template {import('@appium/types').StringRecord} C\n   * @param {C} caps\n   * @returns {MatchedDriver}\n   */\n  findMatchingDriver({automationName, platformName}) {\n    if (!_.isString(platformName)) {\n      throw new Error('You must include a platformName capability');\n    }\n\n    if (!_.isString(automationName)) {\n      throw new Error('You must include an automationName capability');\n    }\n\n    log.info(\n      `Attempting to find matching driver for automationName ` +\n        `'${automationName}' and platformName '${platformName}'`\n    );\n\n    try {\n      const {driverName, mainClass, version} = this._getDriverBySupport(\n        automationName,\n        platformName\n      );\n      log.info(`The '${driverName}' driver was installed and matched caps.`);\n      log.info(`Will require it at ${this.getInstallPath(driverName)}`);\n      const driver = this.require(driverName);\n      if (!driver) {\n        throw new Error(\n          `Driver '${driverName}' did not export a class with name '${mainClass}'. Contact the author of the driver!`\n        );\n      }\n      return {driver, version, driverName};\n    } catch (err) {\n      const msg =\n        `Could not find a driver for automationName ` +\n        `'${automationName}' and platformName ${platformName}'. ` +\n        `Have you installed a driver that supports those ` +\n        `capabilities? Run 'appium driver list --installed' to see. ` +\n        `(Lower-level error: ${err.message})`;\n      throw new Error(msg);\n    }\n  }\n\n  /**\n   * Given an automation name and platform name, find a suitable driver and return its extension data.\n   * @param {string} matchAutomationName\n   * @param {string} matchPlatformName\n   * @returns {ExtMetadata<DriverType> & import('appium/types').InternalMetadata & import('appium/types').CommonExtMetadata}\n   */\n  _getDriverBySupport(matchAutomationName, matchPlatformName) {\n    const drivers = this.installedExtensions;\n    for (const [driverName, driverData] of _.toPairs(drivers)) {\n      const {automationName, platformNames} = driverData;\n      const aNameMatches = automationName.toLowerCase() === matchAutomationName.toLowerCase();\n      const pNameMatches = _.includes(\n        platformNames.map(_.toLower),\n        matchPlatformName.toLowerCase()\n      );\n\n      if (aNameMatches && pNameMatches) {\n        return {driverName, ...driverData};\n      }\n\n      if (aNameMatches) {\n        throw new Error(\n          `Driver '${driverName}' supports automationName ` +\n            `'${automationName}', but Appium could not find ` +\n            `support for platformName '${matchPlatformName}'. Supported ` +\n            `platformNames are: ` +\n            JSON.stringify(platformNames)\n        );\n      }\n    }\n\n    throw new Error(`Could not find installed driver to support given caps`);\n  }\n}\n\n/**\n * @template T\n * @typedef {import('appium/types').ExtMetadata<T>} ExtMetadata\n */\n\n/**\n * @template T\n * @typedef {import('appium/types').ExtManifest<T>} ExtManifest\n */\n\n/**\n * @typedef {import('appium/types').ManifestData} ManifestData\n * @typedef {import('@appium/types').DriverType} DriverType\n * @typedef {import('./manifest').Manifest} Manifest\n */\n\n/**\n * @template T\n * @typedef {import('appium/types').ExtRecord<T>} ExtRecord\n */\n\n/**\n * @template T\n * @typedef {import('appium/types').ExtName<T>} ExtName\n */\n\n/**\n * Return value of {@linkcode DriverConfig.findMatchingDriver}\n * @typedef MatchedDriver\n * @property {import('@appium/types').DriverClass} driver\n * @property {string} version\n * @property {string} driverName\n */\n\n/**\n * @typedef {import('@appium/types').Capabilities} Capabilities\n */\n"],"mappings":"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"}