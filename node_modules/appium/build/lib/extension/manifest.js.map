{"version":3,"file":"manifest.js","names":["CONFIG_SCHEMA_REV","CONFIG_DATA_DRIVER_KEY","DRIVER_TYPE","CONFIG_DATA_PLUGIN_KEY","PLUGIN_TYPE","INITIAL_MANIFEST_DATA","Object","freeze","schemaRev","isExtension","value","_","isPlainObject","appium","isString","name","version","isDriver","get","isArray","isPlugin","Manifest","_data","_appiumHome","_manifestPath","_writing","_reading","constructor","appiumHome","cloneDeep","getInstance","memoize","_getInstance","syncWithInstalledExtensions","didChange","onMatch","filepath","pkg","JSON","parse","fs","readFile","changed","addExtensionFromPackage","queue","path","join","B","resolve","reject","glob","cwd","silent","absolute","err","on","push","all","hasDriver","Boolean","drivers","hasPlugin","plugins","pkgJson","pkgPath","extensionPath","dirname","internal","pkgName","appiumVersion","peerDependencies","installType","INSTALL_TYPE_NPM","installSpec","driverName","addExtension","omit","pluginName","TypeError","extType","extName","extData","data","clone","manifestPath","getExtensionData","read","isNewFile","_setManifestPath","log","debug","yaml","YAML","stringify","code","Error","message","installedExtensionsChanged","env","hasAppiumDependency","packageDidChange","write","undefined","resolveManifestPath","relative","startsWith","mkdirp","writeFile"],"sources":["../../../lib/extension/manifest.js"],"sourcesContent":["/**\n * Module containing {@link Manifest} which handles reading & writing of extension config files.\n */\n\nimport B from 'bluebird';\nimport glob from 'glob';\nimport {env, fs} from '@appium/support';\nimport _ from 'lodash';\nimport path from 'path';\nimport YAML from 'yaml';\nimport {DRIVER_TYPE, PLUGIN_TYPE} from '../constants';\nimport log from '../logger';\nimport {INSTALL_TYPE_NPM} from './extension-config';\nimport {packageDidChange} from './package-changed';\n\n/**\n * Current configuration schema revision!\n */\nconst CONFIG_SCHEMA_REV = 2;\n\n/**\n * The name of the prop (`drivers`) used in `extensions.yaml` for drivers.\n * @type {`${typeof DRIVER_TYPE}s`}\n */\nconst CONFIG_DATA_DRIVER_KEY = `${DRIVER_TYPE}s`;\n\n/**\n * The name of the prop (`plugins`) used in `extensions.yaml` for plugins.\n * @type {`${typeof PLUGIN_TYPE}s`}\n */\nconst CONFIG_DATA_PLUGIN_KEY = `${PLUGIN_TYPE}s`;\n\n/**\n * @type {Readonly<ManifestData>}\n */\nconst INITIAL_MANIFEST_DATA = Object.freeze({\n  [CONFIG_DATA_DRIVER_KEY]: Object.freeze({}),\n  [CONFIG_DATA_PLUGIN_KEY]: Object.freeze({}),\n  schemaRev: CONFIG_SCHEMA_REV,\n});\n\n/**\n * Given a `package.json` return `true` if it represents an Appium Extension (either a driver or plugin).\n *\n * The `package.json` must have an `appium` property which is an object.\n * @param {any} value\n * @returns {value is ExtPackageJson<ExtensionType>}\n */\nfunction isExtension(value) {\n  return (\n    _.isPlainObject(value) &&\n    _.isPlainObject(value.appium) &&\n    _.isString(value.name) &&\n    _.isString(value.version)\n  );\n}\n/**\n * Given a `package.json`, return `true` if it represents an Appium Driver.\n *\n * To be considered a driver, a `package.json` must have a fields\n * `appium.driverName`, `appium.automationName` and `appium.platformNames`.\n * @param {any} value - Value to test\n * @returns {value is ExtPackageJson<DriverType>}\n */\nfunction isDriver(value) {\n  return (\n    isExtension(value) &&\n    _.isString(_.get(value, 'appium.driverName')) &&\n    _.isString(_.get(value, 'appium.automationName')) &&\n    _.isArray(_.get(value, 'appium.platformNames'))\n  );\n}\n\n/**\n * Given a `package.json`, return `true` if it represents an Appium Plugin.\n *\n * To be considered a plugin, a `package.json` must have an `appium.pluginName` field.\n * @param {any} value - Value to test\n * @returns {value is ExtPackageJson<PluginType>}\n */\nfunction isPlugin(value) {\n  return isExtension(value) && _.isString(_.get(value, 'appium.pluginName'));\n}\n\n/**\n * Handles reading & writing of extension config files.\n *\n * Only one instance of this class exists per value of `APPIUM_HOME`.\n */\nexport class Manifest {\n  /**\n   * The entire contents of a parsed YAML extension config file.\n   *\n   * Contains proxies for automatic persistence on disk\n   * @type {ManifestData}\n   * @private\n   */\n  _data;\n\n  /**\n   * Path to `APPIUM_HOME`.\n   * @private\n   * @type {Readonly<string>}\n   */\n  _appiumHome;\n\n  /**\n   * Path to `extensions.yaml`\n   * @type {string}\n   * Not set until {@link Manifest.read} is called.\n   */\n  _manifestPath;\n\n  /**\n   * Helps avoid writing multiple times.\n   *\n   * If this is `undefined`, calling {@link Manifest.write} will cause it to be\n   * set to a `Promise`. When the call to `write()` is complete, the `Promise`\n   * will resolve and then this value will be set to `undefined`.  Concurrent calls\n   * made while this value is a `Promise` will return the `Promise` itself.\n   * @private\n   * @type {Promise<boolean>|undefined}\n   */\n  _writing;\n\n  /**\n   * Helps avoid reading multiple times.\n   *\n   * If this is `undefined`, calling {@link Manifest.read} will cause it to be\n   * set to a `Promise`. When the call to `read()` is complete, the `Promise`\n   * will resolve and then this value will be set to `undefined`.  Concurrent calls\n   * made while this value is a `Promise` will return the `Promise` itself.\n   * @private\n   * @type {Promise<void>|undefined}\n   */\n  _reading;\n\n  /**\n   * Sets internal data to a fresh clone of {@link INITIAL_MANIFEST_DATA}\n   *\n   * Use {@link Manifest.getInstance} instead.\n   * @param {string} appiumHome\n   * @private\n   */\n  constructor(appiumHome) {\n    this._appiumHome = appiumHome;\n    this._data = _.cloneDeep(INITIAL_MANIFEST_DATA);\n  }\n\n  /**\n   * Returns a new or existing {@link Manifest} instance, based on the value of `appiumHome`.\n   *\n   * Maintains one instance per value of `appiumHome`.\n   * @param {string} appiumHome - Path to `APPIUM_HOME`\n   * @returns {Manifest}\n   */\n  static getInstance = _.memoize(function _getInstance(appiumHome) {\n    return new Manifest(appiumHome);\n  });\n\n  /**\n   * Searches `APPIUM_HOME` for installed extensions and adds them to the manifest.\n   * @returns {Promise<boolean>} `true` if any extensions were added, `false` otherwise.\n   */\n  async syncWithInstalledExtensions() {\n    // this could be parallelized, but we can't use fs.walk as an async iterator\n    let didChange = false;\n\n    /**\n     * Listener for the `match` event of a `glob` instance\n     * @param {string} filepath - Path to a `package.json`\n     * @returns {Promise<void>}\n     */\n    const onMatch = async (filepath) => {\n      try {\n        const pkg = JSON.parse(await fs.readFile(filepath, 'utf8'));\n        if (isDriver(pkg) || isPlugin(pkg)) {\n          const changed = this.addExtensionFromPackage(pkg, filepath);\n          didChange = didChange || changed;\n        }\n      } catch {}\n    };\n\n    /**\n     * A list of `Promise`s which read `package.json` files looking for Appium extensions.\n     * @type {Promise<void>[]}\n     */\n    const queue = [\n      // look at `package.json` in `APPIUM_HOME` only\n      onMatch(path.join(this._appiumHome, 'package.json')),\n    ];\n\n    // add dependencies to the queue\n    await new B((resolve, reject) => {\n      glob(\n        'node_modules/{*,@*/*}/package.json',\n        {cwd: this._appiumHome, silent: true, absolute: true},\n        // eslint-disable-next-line promise/prefer-await-to-callbacks\n        (err) => {\n          if (err) {\n            reject(err);\n          }\n          resolve();\n        }\n      )\n        .on('error', reject)\n        .on('match', (filepath) => {\n          queue.push(onMatch(filepath));\n        });\n    });\n\n    // wait for everything to finish\n    await B.all(queue);\n\n    return didChange;\n  }\n\n  /**\n   * Returns `true` if driver with name `name` is registered.\n   * @param {string} name - Driver name\n   * @returns {boolean}\n   */\n  hasDriver(name) {\n    return Boolean(this._data.drivers[name]);\n  }\n\n  /**\n   * Returns `true` if plugin with name `name` is registered.\n   * @param {string} name - Plugin name\n   * @returns {boolean}\n   */\n  hasPlugin(name) {\n    return Boolean(this._data.plugins[name]);\n  }\n\n  /**\n   * Given a path to a `package.json`, add it as either a driver or plugin to the manifest.\n   *\n   * Will _not_ overwrite existing entries.\n   * @template {ExtensionType} ExtType\n   * @param {ExtPackageJson<ExtType>} pkgJson\n   * @param {string} pkgPath\n   * @returns {boolean} - `true` upon success, `false` if the extension is already registered.\n   */\n  addExtensionFromPackage(pkgJson, pkgPath) {\n    const extensionPath = path.dirname(pkgPath);\n\n    /**\n     * @type {InternalMetadata}\n     */\n    const internal = {\n      pkgName: pkgJson.name,\n      version: pkgJson.version,\n      appiumVersion: pkgJson.peerDependencies?.appium,\n      installType: INSTALL_TYPE_NPM,\n      installSpec: `${pkgJson.name}@${pkgJson.version}`,\n    };\n\n    if (isDriver(pkgJson)) {\n      if (!this.hasDriver(pkgJson.appium.driverName)) {\n        this.addExtension(DRIVER_TYPE, pkgJson.appium.driverName, {\n          ..._.omit(pkgJson.appium, 'driverName'),\n          ...internal,\n        });\n        return true;\n      }\n      return false;\n    } else if (isPlugin(pkgJson)) {\n      if (!this.hasPlugin(pkgJson.appium.pluginName)) {\n        this.addExtension(PLUGIN_TYPE, pkgJson.appium.pluginName, {\n          ..._.omit(pkgJson.appium, 'pluginName'),\n          ...internal,\n        });\n        return true;\n      }\n      return false;\n    } else {\n      throw new TypeError(\n        `The extension in ${extensionPath} is neither a valid driver nor a valid plugin.`\n      );\n    }\n  }\n\n  /**\n   * Adds an extension to the manifest as was installed by the `appium` CLI.  The\n   * `extData`, `extType`, and `extName` have already been determined.\n   *\n   * See {@link Manifest.addExtensionFromPackage} for adding an extension from an on-disk package.\n   * @template {ExtensionType} ExtType\n   * @param {ExtType} extType - `driver` or `plugin`\n   * @param {string} extName - Name of extension\n   * @param {ExtManifest<ExtType>} extData - Extension metadata\n   * @returns {ExtManifest<ExtType>} A clone of `extData`, potentially with a mutated `appiumVersion` field\n   */\n  addExtension(extType, extName, extData) {\n    const data = _.clone(extData);\n    this._data[`${extType}s`][extName] = data;\n    return data;\n  }\n\n  /**\n   * Returns the APPIUM_HOME path\n   */\n  get appiumHome() {\n    return this._appiumHome;\n  }\n\n  /**\n   * Returns the path to the manifest file\n   */\n  get manifestPath() {\n    return this._manifestPath;\n  }\n\n  /**\n   * Returns extension data for a particular type.\n   *\n   * @template {ExtensionType} ExtType\n   * @param {ExtType} extType\n   * @returns {ExtRecord<ExtType>}\n   */\n  getExtensionData(extType) {\n    return this._data[/** @type {string} */ (`${extType}s`)];\n  }\n\n  /**\n   * Reads manifest from disk and _overwrites_ the internal data.\n   *\n   * If the manifest does not exist on disk, an {@link INITIAL_MANIFEST_DATA \"empty\"} manifest file will be created.\n   *\n   * If `APPIUM_HOME` contains a `package.json` with an `appium` dependency, then a hash of the `package.json` will be taken. If this hash differs from the last hash, the contents of `APPIUM_HOME/node_modules` will be scanned for extensions that may have been installed outside of the `appium` CLI.  Any found extensions will be added to the manifest file, and if so, the manifest file will be written to disk.\n   *\n   * Only one read operation should happen at a time.  This is controlled via the {@link Manifest._reading} property.\n   * @returns {Promise<ManifestData>} The data\n   */\n  async read() {\n    if (this._reading) {\n      await this._reading;\n      return this._data;\n    }\n\n    this._reading = (async () => {\n      /** @type {ManifestData} */\n      let data;\n      let isNewFile = false;\n      await this._setManifestPath();\n      try {\n        log.debug(`Reading ${this._manifestPath}...`);\n        const yaml = await fs.readFile(this._manifestPath, 'utf8');\n        data = YAML.parse(yaml);\n        log.debug(`Parsed manifest file: ${JSON.stringify(data, null, 2)}`);\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          data = _.cloneDeep(INITIAL_MANIFEST_DATA);\n          isNewFile = true;\n        } else {\n          if (this._manifestPath) {\n            throw new Error(\n              `Appium had trouble loading the extension installation ` +\n                `cache file (${this._manifestPath}). It may be invalid YAML. Specific error: ${err.message}`\n            );\n          } else {\n            throw new Error(\n              `Appium encountered an unknown problem. Specific error: ${err.message}`\n            );\n          }\n        }\n      }\n\n      this._data = data;\n      let installedExtensionsChanged = false;\n      if (\n        (await env.hasAppiumDependency(this.appiumHome)) &&\n        (await packageDidChange(this.appiumHome))\n      ) {\n        installedExtensionsChanged = await this.syncWithInstalledExtensions();\n      }\n\n      if (isNewFile || installedExtensionsChanged) {\n        await this.write();\n      }\n    })();\n    try {\n      await this._reading;\n      return this._data;\n    } finally {\n      this._reading = undefined;\n    }\n  }\n\n  /**\n   * Ensures {@link Manifest._manifestPath} is set.\n   *\n   * Creates the directory if necessary.\n   * @private\n   * @returns {Promise<string>}\n   */\n  async _setManifestPath() {\n    if (!this._manifestPath) {\n      this._manifestPath = await env.resolveManifestPath(this._appiumHome);\n\n      /* istanbul ignore if */\n      if (path.relative(this._appiumHome, this._manifestPath).startsWith('.')) {\n        throw new Error(\n          `Mismatch between location of APPIUM_HOME and manifest file. APPIUM_HOME: ${this.appiumHome}, manifest file: ${this._manifestPath}`\n        );\n      }\n    }\n\n    return this._manifestPath;\n  }\n\n  /**\n   * Writes the data if it need s writing.\n   *\n   * If the `schemaRev` prop needs updating, the file will be written.\n   *\n   * @todo If this becomes too much of a bottleneck, throttle it.\n   * @returns {Promise<boolean>} Whether the data was written\n   */\n  async write() {\n    if (this._writing) {\n      return this._writing;\n    }\n    this._writing = (async () => {\n      await this._setManifestPath();\n      try {\n        await fs.mkdirp(path.dirname(this._manifestPath));\n      } catch (err) {\n        throw new Error(\n          `Appium could not create the directory for the manifest file: ${path.dirname(\n            this._manifestPath\n          )}. Original error: ${err.message}`\n        );\n      }\n      try {\n        await fs.writeFile(this._manifestPath, YAML.stringify(this._data), 'utf8');\n        return true;\n      } catch (err) {\n        throw new Error(\n          `Appium could not write to manifest at ${this._manifestPath} using APPIUM_HOME ${this._appiumHome}. ` +\n            `Please ensure it is writable. Original error: ${err.message}`\n        );\n      }\n    })();\n    try {\n      return await this._writing;\n    } finally {\n      this._writing = undefined;\n    }\n  }\n}\n\n/**\n * Type of the string referring to a driver (typically as a key or type string)\n * @typedef {import('@appium/types').DriverType} DriverType\n */\n\n/**\n * Type of the string referring to a plugin (typically as a key or type string)\n * @typedef {import('@appium/types').PluginType} PluginType\n */\n\n/**\n * @typedef SyncWithInstalledExtensionsOpts\n * @property {number} [depthLimit] - Maximum depth to recurse into subdirectories\n */\n\n/**\n * @typedef {import('appium/types').ManifestData} ManifestData\n * @typedef {import('appium/types').InternalMetadata} InternalMetadata\n */\n\n/**\n * @template T\n * @typedef {import('appium/types').ExtPackageJson<T>} ExtPackageJson\n */\n\n/**\n * @template T\n * @typedef {import('appium/types').ExtManifest<T>} ExtManifest\n */\n\n/**\n * @template T\n * @typedef {import('appium/types').ExtRecord<T>} ExtRecord\n */\n\n/**\n * Either `driver` or `plugin` rn\n * @typedef {import('@appium/types').ExtensionType} ExtensionType\n */\n"],"mappings":"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"}