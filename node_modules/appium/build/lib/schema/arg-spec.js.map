{"version":3,"file":"arg-spec.js","names":["APPIUM_CONFIG_SCHEMA_ID","SERVER_PROP_NAME","SCHEMA_ID_REGEXP","PROPERTIES","ArgSpec","name","extType","extName","ref","arg","dest","rawDest","defaultValue","constructor","toArg","toSchemaRef","_","camelCase","destKeypath","join","baseRef","toSchemaBaseRef","toNormalizedExtName","properName","kebabCase","replace","extensionInfoFromRootSchemaId","schemaId","matches","match","groups","normalizedExtName","create","opts","Object","freeze","toString","str"],"sources":["../../../lib/schema/arg-spec.js"],"sourcesContent":["import _ from 'lodash';\n\n/**\n * The original ID of the Appium config schema.\n * We use this in the CLI to convert it to `argparse` options.\n */\nexport const APPIUM_CONFIG_SCHEMA_ID = 'appium.json';\n\n/**\n * The schema prop containing server-related options. Everything in here\n * is \"native\" to Appium.\n * Used by {@link flattenSchema} for transforming the schema into CLI args.\n */\nexport const SERVER_PROP_NAME = 'server';\n\n/**\n * Used to parse extension info from a schema ID.\n */\nconst SCHEMA_ID_REGEXP = /^(?<extType>.+?)-(?<normalizedExtName>.+)\\.json$/;\n\n/**\n * Avoid typos by using constants!\n */\nconst PROPERTIES = 'properties';\n\n/**\n * An `ArgSpec` is a class representing metadata about an argument (or config\n * option) used for cross-referencing.\n *\n * This class has no instance methods, and is basically just a read-only \"struct\".\n * @template D\n */\nexport class ArgSpec {\n  /**\n   * The canonical name of the argument. Corresponds to key in schema's `properties` prop.\n   * @type {string}\n   */\n  name;\n\n  /**\n   * The `ExtensionType` of the argument. This will be set if the arg came from an extension;\n   * otherwise it will be `undefined`.\n   * @type {ExtensionType|undefined}\n   */\n  extType;\n\n  /**\n   * The name of the extension, if this argument came from an extension.\n   *\n   * Otherwise `undefined`.\n   * @type {string|undefined}\n   */\n  extName;\n\n  /**\n   * The schema ID (`$id`) for the argument.  This is automatically determined, and any user-provided `$id`s will be overwritten.\n   *\n   * @type {string}\n   */\n  ref;\n\n  /**\n   * The CLI argument, sans leading dashes.\n   * @type {string}\n   */\n  arg;\n\n  /**\n   * The desired keypath for the argument after arguments have been parsed.\n   *\n   * Typically this is camelCased.  If the arg came from an extension, it will be prefixed with\n   * `<extType>.<extName>.`\n   * @type {string}\n   */\n  dest;\n\n  /**\n   * The same as {@link ArgSpec.dest} but without the leading `<extType>.<extName>.` prefix.\n   */\n  rawDest;\n\n  /**\n   * Whatever the default value of this argument is, as specified by the\n   * `default` property of the schema.\n   * @type {D|undefined}\n   */\n  defaultValue;\n\n  /**\n   * Builds some computed fields and assigns them to the instance.\n   *\n   * Undefined properties are not assigned.\n   *\n   * The _constructor_ is private. Use {@link ArgSpec.create} instead.\n   * @private\n   * @param {string} name\n   * @param {ArgSpecOptions<D>} [opts]\n   */\n  constructor(name, {extType, extName, dest, defaultValue} = {}) {\n    // we must normalize the extension name to fit into our convention for CLI\n    // args.\n    const arg = ArgSpec.toArg(name, extType, extName);\n\n    const ref = ArgSpec.toSchemaRef(name, extType, extName);\n\n    // if no explicit `dest` provided, just camelCase the name to avoid needing\n    // to use bracket syntax when accessing props on the parsed args object.\n    const rawDest = _.camelCase(dest ?? name);\n\n    const destKeypath = extType && extName ? [extType, extName, rawDest].join('.') : rawDest;\n\n    this.defaultValue = defaultValue;\n    this.name = name;\n    this.extType = extType;\n    this.extName = extName;\n    this.arg = arg;\n    this.dest = destKeypath;\n    this.ref = ref;\n    this.rawDest = rawDest;\n  }\n\n  /**\n   * Return the schema ID (`$id`) for the **argument** given the parameters.\n   *\n   * If you need the \"root\" or \"base\" schema ID, use {@link ArgSpec.toSchemaBaseRef} instead.\n   * @param {string} name - Argument name\n   * @param {ExtensionType} [extType] - Extension type\n   * @param {string} [extName] - Extension name\n   * @returns {string} Schema ID\n   */\n  static toSchemaRef(name, extType, extName) {\n    const baseRef = ArgSpec.toSchemaBaseRef(extType, extName);\n    if (extType && extName) {\n      return [`${baseRef}#`, PROPERTIES, name].join('/');\n    }\n    return [`${baseRef}#`, PROPERTIES, SERVER_PROP_NAME, PROPERTIES, name].join('/');\n  }\n\n  /**\n   * Return the schema ID for an extension or the base schema ID.\n   * @param {ExtensionType} [extType] - Extension type\n   * @param {string} [extName] - Extension name\n   */\n  static toSchemaBaseRef(extType, extName) {\n    if (extType && extName) {\n      return `${extType}-${ArgSpec.toNormalizedExtName(extName)}.json`;\n    }\n    return APPIUM_CONFIG_SCHEMA_ID;\n  }\n\n  /**\n   * Return the unique ID for the argument given the parameters.\n   * @param {string} name - Argument name\n   * @param {ExtensionType} [extType] - Extension type\n   * @param {string} [extName] - Extension name\n   * @returns {string} Unique ID\n   */\n  static toArg(name, extType, extName) {\n    const properName = _.kebabCase(name.replace(/^--?/, ''));\n    if (extType && extName) {\n      return [extType, _.kebabCase(extName), properName].join('-');\n    }\n    return properName;\n  }\n\n  /**\n   * Normalizes a raw extension name (not including the type).\n   * @param {string} extName - Extension name\n   * @returns {string} Normalized extension name\n   */\n  static toNormalizedExtName(extName) {\n    return _.kebabCase(extName);\n  }\n\n  /**\n   * When given the root ID of a schema for an extension (`<extType>-<normalizedExtName>.json`) Returns an object containing the extension type and the _normalized_ extension name.\n   * @param {string} schemaId - Root schema ID\n   * @returns { {extType?: ExtensionType, normalizedExtName?: string} }\n   */\n  static extensionInfoFromRootSchemaId(schemaId) {\n    const matches = schemaId.match(SCHEMA_ID_REGEXP);\n    if (matches?.groups) {\n      const {extType, normalizedExtName} =\n        /** @type { {extType: ExtensionType, normalizedExtName: string} } */ (matches.groups);\n      return {extType, normalizedExtName};\n    }\n    return {};\n  }\n\n  /**\n   * Creates an `ArgSpec`\n   *\n   * @param {string} name - The canonical name of the argument. Corresponds to a key in a schema's\n   * `properties` property.\n   * @template D\n   * @param {ArgSpecOptions<D>} [opts] - Options\n   * @returns {Readonly<ArgSpec>}\n   */\n  static create(name, opts) {\n    return Object.freeze(new ArgSpec(name, opts));\n  }\n\n  /**\n   * String representation, useful for debugging\n   * @returns {string}\n   */\n  /* istanbul ignore next */\n  toString() {\n    let str = `[ArgSpec] ${this.name} (${this.ref})`;\n    if (this.extType && this.extName) {\n      str += ` (ext: ${this.extType}/${this.extName})`;\n    }\n    return str;\n  }\n}\n\n/**\n * Options for {@link ArgSpec.create}\n * @template D\n * @typedef ArgSpecOptions\n * @property {string} [extName]\n * @property {ExtensionType} [extType]\n * @property {string} [dest]\n * @property {D} [defaultValue]\n */\n\n/**\n * @typedef {import('@appium/types').ExtensionType} ExtensionType\n */\n"],"mappings":"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"}