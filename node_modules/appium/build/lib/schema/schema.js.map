{"version":3,"file":"schema.js","names":["RoachHotelMap","Map","set","key","value","has","Error","delete","clear","ALLOWED_SCHEMA_EXTENSIONS","Set","AppiumSchema","_argSpecs","_registeredSchemas","DRIVER_TYPE","PLUGIN_TYPE","_ajv","_instance","_finalizedSchemas","constructor","_instantiateAjv","create","instance","_","bindAll","hasRegisteredSchema","extType","extName","isFinalized","Boolean","getAllArgSpecs","finalize","ajv","baseSchema","cloneDeep","AppiumConfigJsonSchema","addArgSpecs","schema","propName","propSchema","Object","entries","argSpec","ArgSpec","dest","appiumCliDest","defaultValue","default","arg","omit","properties","server","finalizedSchemas","finalSchema","reduce","extensionSchemas","forEach","$ref","toSchemaBaseRef","$id","additionalProperties","$comment","validateSchema","addSchema","APPIUM_CONFIG_SCHEMA_ID","freeze","addFormats","Ajv","allErrors","keywords","keyword","addKeyword","reset","schemaId","keys","removeSchema","registerSchema","isUndefined","TypeError","isSupportedSchemaType","SchemaUnsupportedSchemaError","normalizedExtName","kebabCase","get","SchemaNameConflictError","getArgSpec","name","toArg","hasArgSpec","getDefaults","flatten","SchemaFinalizationError","reducer","defaults","retval","values","getDefaultsForExtension","specs","filter","spec","rawDest","getSchema","stack","prefix","flattened","pairs","toPairs","push","SERVER_PROP_NAME","refSchema","err","SchemaUnknownSchemaError","extensionInfoFromRootSchemaId","ReferenceError","ref","_getValidator","id","validator","validate","isArray","errors","isAllowedSchemaFileExtension","filename","path","extname","isPlainObject","$async","code","data","msg","isBoolean","JSON","stringify","appiumSchema","finalizeSchema","resetSchema","flattenSchema","getDefaultsForSchema"],"sources":["../../../lib/schema/schema.js"],"sourcesContent":["import Ajv from 'ajv';\nimport addFormats from 'ajv-formats';\nimport _ from 'lodash';\nimport path from 'path';\nimport {DRIVER_TYPE, PLUGIN_TYPE} from '../constants';\nimport {AppiumConfigJsonSchema} from '@appium/schema';\nimport {APPIUM_CONFIG_SCHEMA_ID, ArgSpec, SERVER_PROP_NAME} from './arg-spec';\nimport {keywords} from './keywords';\n\n/**\n * Key/value pairs go in... but they don't come out.\n *\n * @template K,V\n * @extends {Map<K,V>}\n */\nexport class RoachHotelMap extends Map {\n  /**\n   * @param {K} key\n   * @param {V} value\n   */\n  set(key, value) {\n    if (this.has(key)) {\n      throw new Error(`${key} is already set`);\n    }\n    return super.set(key, value);\n  }\n\n  /**\n   * @param {K} key\n   */\n  // eslint-disable-next-line no-unused-vars\n  delete(key) {\n    return false;\n  }\n\n  clear() {\n    throw new Error(`Cannot clear RoachHotelMap`);\n  }\n}\n\n/**\n * Extensions that an extension schema file can have.\n */\nexport const ALLOWED_SCHEMA_EXTENSIONS = new Set(['.json', '.js', '.cjs']);\n\n/**\n * A wrapper around Ajv and schema-related functions.\n *\n * Should have been named Highlander, because _there can only be one_\n */\nclass AppiumSchema {\n  /**\n   * A mapping of unique argument IDs to their corresponding {@link ArgSpec}s.\n   *\n   * An \"argument\" is a CLI argument or a config property.\n   *\n   * Used to provide easy lookups of argument metadata when converting between different representations of those arguments.\n   * @private\n   * @type {RoachHotelMap<string,ArgSpec>}\n   */\n  _argSpecs = new RoachHotelMap();\n\n  /**\n   * A map of extension types to extension names to schema objects.\n   *\n   * This data structure is used to ensure there are no naming conflicts. The schemas\n   * are stored here in memory until the instance is _finalized_.\n   * @private\n   * @type {Record<ExtensionType,Map<string,SchemaObject>>}\n   */\n  _registeredSchemas = {[DRIVER_TYPE]: new Map(), [PLUGIN_TYPE]: new Map()};\n\n  /**\n   * Ajv instance\n   *\n   * @private\n   * @type {Ajv}\n   */\n  _ajv;\n\n  /**\n   * Singleton instance.\n   * @private\n   * @type {AppiumSchema}\n   */\n  static _instance;\n\n  /**\n   * Lookup of schema IDs to finalized schemas.\n   *\n   * This does not include references, but rather the root schemas themselves.\n   * @private\n   * @type {Record<string,StrictSchemaObject>?}\n   */\n  _finalizedSchemas = null;\n\n  /**\n   * Initializes Ajv, adds standard formats and our custom keywords.\n   * @see https://npm.im/ajv-formats\n   * @private\n   */\n  constructor() {\n    this._ajv = AppiumSchema._instantiateAjv();\n  }\n\n  /**\n   * Factory function for {@link AppiumSchema} instances.\n   *\n   * Returns a singleton instance if one exists, otherwise creates a new one.\n   * Binds public methods to the instance.\n   * @returns {AppiumSchema}\n   */\n  static create() {\n    if (!AppiumSchema._instance) {\n      const instance = new AppiumSchema();\n      AppiumSchema._instance = instance;\n      _.bindAll(instance, [\n        'finalize',\n        'flatten',\n        'getAllArgSpecs',\n        'getArgSpec',\n        'getDefaults',\n        'getDefaultsForExtension',\n        'getSchema',\n        'hasArgSpec',\n        'isFinalized',\n        'registerSchema',\n        'hasRegisteredSchema',\n        'reset',\n        'validate',\n      ]);\n    }\n\n    return AppiumSchema._instance;\n  }\n\n  /**\n   * Returns `true` if a schema has been registered using given extension type and name.\n   *\n   * This does not depend on whether or not the instance has been _finalized_.\n   * @param {ExtensionType} extType - Extension type\n   * @param {string} extName - Name\n   * @returns {boolean} If registered\n   */\n  hasRegisteredSchema(extType, extName) {\n    return this._registeredSchemas[extType].has(extName);\n  }\n\n  /**\n   * Return `true` if {@link AppiumSchema.finalize finalize} has been called\n   * successfully and {@link AppiumSchema.reset reset} has not been called since.\n   * @returns {boolean} If finalized\n   */\n  isFinalized() {\n    return Boolean(this._finalizedSchemas);\n  }\n\n  getAllArgSpecs() {\n    return this._argSpecs;\n  }\n\n  /**\n   * Call this when no more schemas will be registered.\n   *\n   * This does three things:\n   * 1. It combines all schemas from extensions into the Appium config schema,\n   *    then adds the result to the `Ajv` instance.\n   * 2. It adds schemas for _each_ argument/property for validation purposes.\n   *    The CLI uses these schemas to validate specific arguments.\n   * 3. The schemas are validated against JSON schema draft-07 (which is the\n   *    only one supported at this time)\n   *\n   * Any method in this instance that needs to interact with the `Ajv` instance\n   * will throw if this method has not been called.\n   *\n   * If the instance has already been finalized, this is a no-op.\n   * @public\n   * @throws {Error} If the schema is not valid\n   * @returns {Readonly<Record<string,StrictSchemaObject>>} Record of schema IDs to full schema objects\n   */\n  finalize() {\n    if (this.isFinalized()) {\n      return /** @type {NonNullable<typeof this._finalizedSchemas>} */ (this._finalizedSchemas);\n    }\n\n    const ajv = this._ajv;\n\n    // Ajv will _mutate_ the schema, so we need to clone it.\n    const baseSchema = _.cloneDeep(AppiumConfigJsonSchema);\n\n    /**\n     *\n     * @param {SchemaObject} schema\n     * @param {ExtensionType} [extType]\n     * @param {string} [extName]\n     */\n    const addArgSpecs = (schema, extType, extName) => {\n      for (let [propName, propSchema] of Object.entries(schema)) {\n        const argSpec = ArgSpec.create(propName, {\n          dest: propSchema.appiumCliDest,\n          defaultValue: propSchema.default,\n          extType,\n          extName,\n        });\n        const {arg} = argSpec;\n        this._argSpecs.set(arg, argSpec);\n      }\n    };\n\n    addArgSpecs(_.omit(baseSchema.properties.server.properties, [DRIVER_TYPE, PLUGIN_TYPE]));\n\n    /**\n     * @type {Record<string,StrictSchemaObject>}\n     */\n    const finalizedSchemas = {};\n\n    const finalSchema = _.reduce(\n      this._registeredSchemas,\n      /**\n       * @param {typeof baseSchema} baseSchema\n       * @param {Map<string,SchemaObject>} extensionSchemas\n       * @param {ExtensionType} extType\n       */\n      (baseSchema, extensionSchemas, extType) => {\n        extensionSchemas.forEach((schema, extName) => {\n          const $ref = ArgSpec.toSchemaBaseRef(extType, extName);\n          schema.$id = $ref;\n          schema.additionalProperties = false; // this makes `schema` become a `StrictSchemaObject`\n          baseSchema.properties.server.properties[extType].properties[extName] = {\n            $ref,\n            $comment: extName,\n          };\n          ajv.validateSchema(schema, true);\n          addArgSpecs(schema.properties, extType, extName);\n          ajv.addSchema(schema, $ref);\n          finalizedSchemas[$ref] = /** @type {StrictSchemaObject} */ (schema);\n        });\n        return baseSchema;\n      },\n      baseSchema\n    );\n\n    ajv.addSchema(finalSchema, APPIUM_CONFIG_SCHEMA_ID);\n    finalizedSchemas[APPIUM_CONFIG_SCHEMA_ID] = finalSchema;\n    ajv.validateSchema(finalSchema, true);\n\n    this._finalizedSchemas = finalizedSchemas;\n    return Object.freeze(finalizedSchemas);\n  }\n\n  /**\n   * Configures and creates an Ajv instance.\n   * @private\n   * @returns {Ajv}\n   */\n  static _instantiateAjv() {\n    const ajv = addFormats(\n      new Ajv({\n        // without this not much validation actually happens\n        allErrors: true,\n      })\n    );\n\n    // add custom keywords to ajv. see schema-keywords.js\n    _.forEach(keywords, (keyword) => {\n      ajv.addKeyword(keyword);\n    });\n\n    return ajv;\n  }\n\n  /**\n   * Resets this instance to its original state.\n   *\n   * - Removes all added schemas from the `Ajv` instance\n   * - Resets the map of {@link ArgSpec ArgSpecs}\n   * - Resets the map of registered schemas\n   * - Sets the {@link AppiumSchema._finalized _finalized} flag to `false`\n   *\n   * If you need to call {@link AppiumSchema.finalize} again, you'll want to call this first.\n   * @returns {void}\n   */\n  reset() {\n    for (const schemaId of Object.keys(this._finalizedSchemas ?? {})) {\n      this._ajv.removeSchema(schemaId);\n    }\n    this._argSpecs = new RoachHotelMap();\n    this._registeredSchemas = {\n      [DRIVER_TYPE]: new Map(),\n      [PLUGIN_TYPE]: new Map(),\n    };\n    this._finalizedSchemas = null;\n\n    // Ajv seems to have an over-eager cache, so we have to dump the object entirely.\n    this._ajv = AppiumSchema._instantiateAjv();\n  }\n\n  /**\n   * Registers a schema from an extension.\n   *\n   * This is \"fail-fast\" in that the schema will immediately be validated against JSON schema draft-07 _or_ whatever the value of the schema's `$schema` prop is.\n   *\n   * Does _not_ add the schema to the `ajv` instance (this is done by {@link AppiumSchema.finalize}).\n   * @param {ExtensionType} extType - Extension type\n   * @param {string} extName - Unique extension name for `type`\n   * @param {SchemaObject} schema - Schema object\n   * @throws {SchemaNameConflictError} If the schema is an invalid\n   * @returns {void}\n   */\n  registerSchema(extType, extName, schema) {\n    if (!(extType && extName) || _.isUndefined(schema)) {\n      throw new TypeError('Expected extension type, extension name, and a defined schema');\n    }\n    if (!AppiumSchema.isSupportedSchemaType(schema)) {\n      throw new SchemaUnsupportedSchemaError(schema, extType, extName);\n    }\n    const normalizedExtName = _.kebabCase(extName);\n    if (this.hasRegisteredSchema(extType, normalizedExtName)) {\n      if (this._registeredSchemas[extType].get(normalizedExtName) === schema) {\n        return;\n      }\n      throw new SchemaNameConflictError(extType, extName);\n    }\n    this._ajv.validateSchema(schema, true);\n\n    this._registeredSchemas[extType].set(normalizedExtName, schema);\n  }\n\n  /**\n   * Returns a {@link ArgSpec} for the given argument name.\n   * @param {string} name - CLI argument name\n   * @param {ExtensionType} [extType] - Extension type\n   * @param {string} [extName] - Extension name\n   * @returns {ArgSpec|undefined} ArgSpec or `undefined` if not found\n   */\n  getArgSpec(name, extType, extName) {\n    return this._argSpecs.get(ArgSpec.toArg(name, extType, extName));\n  }\n\n  /**\n   * Returns `true` if the instance knows about an argument by the given `name`.\n   * @param {string} name - CLI argument name\n   * @param {ExtensionType} [extType] - Extension type\n   * @param {string} [extName] - Extension name\n   * @returns {boolean} `true` if such an {@link ArgSpec} exists\n   */\n  hasArgSpec(name, extType, extName) {\n    return this._argSpecs.has(ArgSpec.toArg(name, extType, extName));\n  }\n\n  /**\n   * Returns a `Record` of argument \"dest\" strings to default values.\n   *\n   * The \"dest\" string is the property name in object returned by\n   * `argparse.ArgumentParser['parse_args']`.\n   * @template {boolean|undefined} Flattened\n   * @param {Flattened} [flatten=true] - If `true`, flattens the returned object\n   * using \"keypath\"-style keys of the format `<extType>.<extName>.<argName>`.\n   * Otherwise, returns a nested object using `extType` and `extName` as\n   * properties. Base arguments (server arguments) are always at the top level.\n   * @returns {DefaultValues<Flattened>}\n   */\n  getDefaults(flatten = /** @type {Flattened} */ (true)) {\n    if (!this.isFinalized()) {\n      throw new SchemaFinalizationError();\n    }\n\n    /**\n     * @private\n     * @callback DefaultReducer\n     * @param {DefaultValues<Flattened>} defaults\n     * @param {ArgSpec} argSpec\n     * @returns {DefaultValues<Flattened>}\n     */\n    /** @type {DefaultReducer} */\n    const reducer = flatten\n      ? (defaults, {defaultValue, dest}) => {\n          if (!_.isUndefined(defaultValue)) {\n            defaults[dest] = defaultValue;\n          }\n          return defaults;\n        }\n      : (defaults, {defaultValue, dest}) => {\n          if (!_.isUndefined(defaultValue)) {\n            _.set(defaults, dest, defaultValue);\n          }\n          return defaults;\n        };\n\n    /** @type {DefaultValues<Flattened>} */\n    const retval = {};\n    return [...this._argSpecs.values()].reduce(reducer, retval);\n  }\n\n  /**\n   * Returns a flattened Record of defaults for a specific extension. Keys will\n   * be of format `<argName>`.\n   * @param {ExtensionType} extType - Extension type\n   * @param {string} extName - Extension name\n   * @returns {Record<string,ArgSpecDefaultValue>}\n   */\n  getDefaultsForExtension(extType, extName) {\n    if (!this.isFinalized()) {\n      throw new SchemaFinalizationError();\n    }\n    const specs = [...this._argSpecs.values()].filter(\n      (spec) => spec.extType === extType && spec.extName === extName\n    );\n    return specs.reduce((defaults, {defaultValue, rawDest}) => {\n      if (!_.isUndefined(defaultValue)) {\n        defaults[rawDest] = defaultValue;\n      }\n      return defaults;\n    }, {});\n  }\n\n  /**\n   * Flatten schema into an array of `SchemaObject`s and associated\n   * {@link ArgSpec ArgSpecs}.\n   *\n   * Converts nested extension schemas to keys based on the extension type and\n   * name. Used when translating to `argparse` options or getting the list of\n   * default values (see {@link AppiumSchema.getDefaults}) for CLI or otherwise.\n   *\n   * The return value is an intermediate reprsentation used by `cli-args`\n   * module's `toParserArgs`, which converts the finalized schema to parameters\n   * used by `argparse`.\n   * @throws If {@link AppiumSchema.finalize} has not been called yet.\n   * @returns {FlattenedSchema}\n   */\n  flatten() {\n    const schema = this.getSchema();\n\n    /** @type { {properties: SchemaObject, prefix: string[]}[] } */\n    const stack = [{properties: schema.properties, prefix: []}];\n    /** @type {FlattenedSchema} */\n    const flattened = [];\n\n    // this bit is a recursive algorithm rewritten as a for loop.\n    // when we find something we want to traverse, we add it to `stack`\n    for (const {properties, prefix} of stack) {\n      const pairs = _.toPairs(properties);\n      for (const [key, value] of pairs) {\n        const {properties, $ref} = value;\n        if (properties) {\n          stack.push({\n            properties,\n            prefix: key === SERVER_PROP_NAME ? [] : [...prefix, key],\n          });\n        } else if ($ref) {\n          let refSchema;\n          try {\n            refSchema = this.getSchema($ref);\n          } catch (err) {\n            // this can happen if an extension schema supplies a $ref to a non-existent schema\n            throw new SchemaUnknownSchemaError($ref);\n          }\n          const {normalizedExtName} = ArgSpec.extensionInfoFromRootSchemaId($ref);\n          if (!normalizedExtName) {\n            /* istanbul ignore next */\n            throw new ReferenceError(\n              `Could not determine extension name from schema ID ${$ref}. This is a bug.`\n            );\n          }\n          stack.push({\n            properties: refSchema.properties,\n            prefix: [...prefix, key, normalizedExtName],\n          });\n        } else if (key !== DRIVER_TYPE && key !== PLUGIN_TYPE) {\n          const [extType, extName] = prefix;\n          const argSpec = this.getArgSpec(key, /** @type {ExtensionType} */ (extType), extName);\n          if (!argSpec) {\n            /* istanbul ignore next */\n            throw new ReferenceError(\n              `Unknown argument with key ${key}, extType ${extType} and extName ${extName}. This is a bug.`\n            );\n          }\n          flattened.push({schema: _.cloneDeep(value), argSpec});\n        }\n      }\n    }\n\n    return flattened;\n  }\n\n  /**\n   * Retrieves the schema itself\n   * @public\n   * @param {string} [ref] - Schema ID\n   * @throws If the schema has not yet been finalized\n   * @returns {SchemaObject}\n   */\n  getSchema(ref = APPIUM_CONFIG_SCHEMA_ID) {\n    return /** @type {SchemaObject} */ (this._getValidator(ref).schema);\n  }\n\n  /**\n   * Retrieves schema validator function from Ajv\n   * @param {string} [id] - Schema ID\n   * @private\n   * @returns {import('ajv').ValidateFunction}\n   */\n  _getValidator(id = APPIUM_CONFIG_SCHEMA_ID) {\n    const validator = this._ajv.getSchema(id);\n    if (!validator) {\n      if (id === APPIUM_CONFIG_SCHEMA_ID) {\n        throw new SchemaFinalizationError();\n      } else {\n        throw new SchemaUnknownSchemaError(id);\n      }\n    }\n    return validator;\n  }\n\n  /**\n   * Given an object, validates it against the Appium config schema.\n   * If errors occur, the returned array will be non-empty.\n   * @param {any} value - The value (hopefully an object) to validate against the schema\n   * @param {string} [ref] - Schema ID or ref.\n   * @public\n   * @returns {import('ajv').ErrorObject[]} Array of errors, if any.\n   */\n  validate(value, ref = APPIUM_CONFIG_SCHEMA_ID) {\n    const validator = this._getValidator(ref);\n    return !validator(value) && _.isArray(validator.errors) ? [...validator.errors] : [];\n  }\n\n  /**\n   * Returns `true` if `filename`'s file extension is allowed (in {@link ALLOWED_SCHEMA_EXTENSIONS}).\n   * @param {string} filename\n   * @returns {boolean}\n   */\n  static isAllowedSchemaFileExtension(filename) {\n    return ALLOWED_SCHEMA_EXTENSIONS.has(path.extname(filename));\n  }\n\n  /**\n   * Returns `true` if `schema` is a plain object with a non-true `$async` property.\n   * @param {any} schema - Schema to check\n   * @returns {schema is SchemaObject}\n   */\n  static isSupportedSchemaType(schema) {\n    return _.isPlainObject(schema) && schema.$async !== true;\n  }\n}\n\n/**\n * Thrown when the {@link AppiumSchema} instance has not yet been finalized, but\n * the method called requires it.\n */\nexport class SchemaFinalizationError extends Error {\n  /**\n   * @type {Readonly<string>}\n   */\n  code = 'APPIUMERR_SCHEMA_FINALIZATION';\n\n  constructor() {\n    super('Schema not yet finalized; `finalize()` must be called first.');\n  }\n}\n\n/**\n * Thrown when a \"unique\" schema ID conflicts with an existing schema ID.\n *\n * This is likely going to be caused by attempting to register the same schema twice.\n */\nexport class SchemaNameConflictError extends Error {\n  /**\n   * @type {Readonly<string>}\n   */\n  code = 'APPIUMERR_SCHEMA_NAME_CONFLICT';\n\n  /**\n   * @type {Readonly<{extType: ExtensionType, extName: string}>}\n   */\n  data;\n\n  /**\n   * @param {ExtensionType} extType\n   * @param {string} extName\n   */\n  constructor(extType, extName) {\n    super(`Name for ${extType} schema \"${extName}\" conflicts with an existing schema`);\n    this.data = {extType, extName};\n  }\n}\n\n/**\n * Thrown when a schema ID was expected, but it doesn't exist on the {@link Ajv} instance.\n */\nexport class SchemaUnknownSchemaError extends ReferenceError {\n  /**\n   * @type {Readonly<string>}\n   */\n  code = 'APPIUMERR_SCHEMA_UNKNOWN_SCHEMA';\n\n  /**\n   * @type {Readonly<{schemaId: string}>}\n   */\n  data;\n\n  /**\n   * @param {string} schemaId\n   */\n  constructor(schemaId) {\n    super(`Unknown schema: \"${schemaId}\"`);\n    this.data = {schemaId};\n  }\n}\n\n/**\n * Thrown when a schema is provided, but it's of an unsupported type.\n *\n * \"Valid\" schemas which are unsupported include boolean schemas and async schemas\n * (having a `true` `$async` property).\n */\nexport class SchemaUnsupportedSchemaError extends TypeError {\n  /**\n   * @type {Readonly<string>}\n   */\n  code = 'APPIUMERR_SCHEMA_UNSUPPORTED_SCHEMA';\n\n  /**\n   * @type {Readonly<{schema: any, extType: ExtensionType, extName: string}>}\n   */\n  data;\n\n  /**\n   * @param {any} schema\n   * @param {ExtensionType} extType\n   * @param {string} extName\n   */\n  constructor(schema, extType, extName) {\n    // https://github.com/Microsoft/TypeScript/issues/8277\n    super(\n      (() => {\n        let msg = `Unsupported schema from ${extType} \"${extName}\":`;\n        if (_.isBoolean(schema)) {\n          return `${msg} schema cannot be a boolean`;\n        }\n        if (_.isPlainObject(schema)) {\n          if (schema.$async) {\n            return `${msg} schema cannot be an async schema`;\n          }\n          /* istanbul ignore next */\n          throw new TypeError(\n            `schema IS supported; this error should not be thrown (this is a bug). value of schema: ${JSON.stringify(\n              schema\n            )}`\n          );\n        }\n        return `${msg} schema must be a plain object without a true \"$async\" property`;\n      })()\n    );\n    this.data = {schema, extType, extName};\n  }\n}\n\nconst appiumSchema = AppiumSchema.create();\n\nexport const {\n  registerSchema,\n  getAllArgSpecs,\n  getArgSpec,\n  hasArgSpec,\n  isFinalized,\n  finalize: finalizeSchema,\n  reset: resetSchema,\n  validate,\n  getSchema,\n  flatten: flattenSchema,\n  getDefaults: getDefaultsForSchema,\n  getDefaultsForExtension,\n} = appiumSchema;\nexport const {isAllowedSchemaFileExtension} = AppiumSchema;\n\n/**\n * Appium only supports schemas that are plain objects; not arrays.\n * @typedef {import('ajv').SchemaObject & {[key: number]: never}} SchemaObject\n */\n\n/**\n * @typedef {import('@appium/types').ExtensionType} ExtensionType\n */\n\n/**\n * An object having property `additionalProperties: false`\n * @typedef StrictProp\n * @property {false} additionalProperties\n */\n\n/**\n * A {@link SchemaObject} with `additionalProperties: false`\n * @typedef {SchemaObject & StrictProp} StrictSchemaObject\n */\n\n/**\n * A list of schemas associated with properties and their corresponding {@link ArgSpec} objects.\n *\n * Intermediate data structure used when converting the entire schema down to CLI arguments.\n * @typedef { {schema: SchemaObject, argSpec: ArgSpec}[] } FlattenedSchema\n */\n\n/**\n * @typedef {ArgSpec['defaultValue']} ArgSpecDefaultValue\n */\n\n/**\n * e.g. `{driver: {foo: 'bar'}}` where `foo` is the arg name and `bar` is the default value.\n * @typedef {Record<string,Record<string,ArgSpecDefaultValue>>} NestedArgSpecDefaultValue\n */\n\n/**\n * Helper type for the return value of {@link AppiumSchema.getDefaults}\n * @template {boolean|undefined} Flattened\n * @typedef {Record<string,Flattened extends true ? ArgSpecDefaultValue : ArgSpecDefaultValue | NestedArgSpecDefaultValue>} DefaultValues\n */\n"],"mappings":"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"}